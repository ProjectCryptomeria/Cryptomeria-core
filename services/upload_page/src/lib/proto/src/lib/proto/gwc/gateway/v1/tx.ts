// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.1
//   protoc               unknown
// source: gwc/gateway/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ManifestPacket } from "./packet";
import { Params } from "./params";
import { DistributeItem, StorageInfo } from "./types";

export const protobufPackage = "gwc.gateway.v1";

export interface MsgUpdateParams {
  authority: string;
  params?: Params | undefined;
}

export interface MsgUpdateParamsResponse {
}

export interface MsgRegisterStorage {
  authority: string;
  storageInfos: StorageInfo[];
}

export interface MsgRegisterStorageResponse {
}

export interface MsgInitSession {
  owner: string;
  /**
   * executorフィールドは削除 (LocalAdmin固定のため)
   * uint64 fragment_size is the fixed fragment size used for splitting files
   */
  fragmentSize: Long;
  /** deadline_unix is the session deadline (unix seconds). 0 means "use chain default". */
  deadlineUnix: Long;
}

export interface MsgInitSessionResponse {
  sessionId: string;
  /** session_upload_token is used by TUS/HTTP upload endpoint (off-chain) to authorize the upload. */
  sessionUploadToken: string;
  /** resolved_deadline_unix is the deadline actually stored in chain state. */
  resolvedDeadlineUnix: Long;
}

export interface MsgCommitRootProof {
  owner: string;
  sessionId: string;
  /** root_proof_hex is the RootProof as hex string. */
  rootProofHex: string;
}

export interface MsgCommitRootProofResponse {
}

export interface MsgDistributeBatch {
  executor: string;
  sessionId: string;
  items: DistributeItem[];
}

export interface MsgDistributeBatchResponse {
}

export interface MsgFinalizeAndCloseSession {
  executor: string;
  sessionId: string;
  /**
   * manifest is sent to MDSC.
   * Session is closed as SUCCESS only after MDSC ACK is received.
   */
  manifest?: ManifestPacket | undefined;
}

export interface MsgFinalizeAndCloseSessionResponse {
}

export interface MsgAbortAndCloseSession {
  executor: string;
  sessionId: string;
  reason: string;
}

export interface MsgAbortAndCloseSessionResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgRegisterStorage(): MsgRegisterStorage {
  return { authority: "", storageInfos: [] };
}

export const MsgRegisterStorage: MessageFns<MsgRegisterStorage> = {
  encode(message: MsgRegisterStorage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    for (const v of message.storageInfos) {
      StorageInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterStorage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storageInfos.push(StorageInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterStorage {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      storageInfos: globalThis.Array.isArray(object?.storageInfos)
        ? object.storageInfos.map((e: any) => StorageInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.storage_infos)
        ? object.storage_infos.map((e: any) => StorageInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgRegisterStorage): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.storageInfos?.length) {
      obj.storageInfos = message.storageInfos.map((e) => StorageInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterStorage>, I>>(base?: I): MsgRegisterStorage {
    return MsgRegisterStorage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterStorage>, I>>(object: I): MsgRegisterStorage {
    const message = createBaseMsgRegisterStorage();
    message.authority = object.authority ?? "";
    message.storageInfos = object.storageInfos?.map((e) => StorageInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgRegisterStorageResponse(): MsgRegisterStorageResponse {
  return {};
}

export const MsgRegisterStorageResponse: MessageFns<MsgRegisterStorageResponse> = {
  encode(_: MsgRegisterStorageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterStorageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterStorageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRegisterStorageResponse {
    return {};
  },

  toJSON(_: MsgRegisterStorageResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRegisterStorageResponse>, I>>(base?: I): MsgRegisterStorageResponse {
    return MsgRegisterStorageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRegisterStorageResponse>, I>>(_: I): MsgRegisterStorageResponse {
    const message = createBaseMsgRegisterStorageResponse();
    return message;
  },
};

function createBaseMsgInitSession(): MsgInitSession {
  return { owner: "", fragmentSize: Long.UZERO, deadlineUnix: Long.ZERO };
}

export const MsgInitSession: MessageFns<MsgInitSession> = {
  encode(message: MsgInitSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (!message.fragmentSize.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.fragmentSize.toString());
    }
    if (!message.deadlineUnix.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.deadlineUnix.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInitSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInitSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fragmentSize = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deadlineUnix = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInitSession {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      fragmentSize: isSet(object.fragmentSize)
        ? Long.fromValue(object.fragmentSize)
        : isSet(object.fragment_size)
        ? Long.fromValue(object.fragment_size)
        : Long.UZERO,
      deadlineUnix: isSet(object.deadlineUnix)
        ? Long.fromValue(object.deadlineUnix)
        : isSet(object.deadline_unix)
        ? Long.fromValue(object.deadline_unix)
        : Long.ZERO,
    };
  },

  toJSON(message: MsgInitSession): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (!message.fragmentSize.equals(Long.UZERO)) {
      obj.fragmentSize = (message.fragmentSize || Long.UZERO).toString();
    }
    if (!message.deadlineUnix.equals(Long.ZERO)) {
      obj.deadlineUnix = (message.deadlineUnix || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgInitSession>, I>>(base?: I): MsgInitSession {
    return MsgInitSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgInitSession>, I>>(object: I): MsgInitSession {
    const message = createBaseMsgInitSession();
    message.owner = object.owner ?? "";
    message.fragmentSize = (object.fragmentSize !== undefined && object.fragmentSize !== null)
      ? Long.fromValue(object.fragmentSize)
      : Long.UZERO;
    message.deadlineUnix = (object.deadlineUnix !== undefined && object.deadlineUnix !== null)
      ? Long.fromValue(object.deadlineUnix)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgInitSessionResponse(): MsgInitSessionResponse {
  return { sessionId: "", sessionUploadToken: "", resolvedDeadlineUnix: Long.ZERO };
}

export const MsgInitSessionResponse: MessageFns<MsgInitSessionResponse> = {
  encode(message: MsgInitSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.sessionUploadToken !== "") {
      writer.uint32(18).string(message.sessionUploadToken);
    }
    if (!message.resolvedDeadlineUnix.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.resolvedDeadlineUnix.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgInitSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgInitSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionUploadToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resolvedDeadlineUnix = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgInitSessionResponse {
    return {
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      sessionUploadToken: isSet(object.sessionUploadToken)
        ? globalThis.String(object.sessionUploadToken)
        : isSet(object.session_upload_token)
        ? globalThis.String(object.session_upload_token)
        : "",
      resolvedDeadlineUnix: isSet(object.resolvedDeadlineUnix)
        ? Long.fromValue(object.resolvedDeadlineUnix)
        : isSet(object.resolved_deadline_unix)
        ? Long.fromValue(object.resolved_deadline_unix)
        : Long.ZERO,
    };
  },

  toJSON(message: MsgInitSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.sessionUploadToken !== "") {
      obj.sessionUploadToken = message.sessionUploadToken;
    }
    if (!message.resolvedDeadlineUnix.equals(Long.ZERO)) {
      obj.resolvedDeadlineUnix = (message.resolvedDeadlineUnix || Long.ZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgInitSessionResponse>, I>>(base?: I): MsgInitSessionResponse {
    return MsgInitSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgInitSessionResponse>, I>>(object: I): MsgInitSessionResponse {
    const message = createBaseMsgInitSessionResponse();
    message.sessionId = object.sessionId ?? "";
    message.sessionUploadToken = object.sessionUploadToken ?? "";
    message.resolvedDeadlineUnix = (object.resolvedDeadlineUnix !== undefined && object.resolvedDeadlineUnix !== null)
      ? Long.fromValue(object.resolvedDeadlineUnix)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgCommitRootProof(): MsgCommitRootProof {
  return { owner: "", sessionId: "", rootProofHex: "" };
}

export const MsgCommitRootProof: MessageFns<MsgCommitRootProof> = {
  encode(message: MsgCommitRootProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.rootProofHex !== "") {
      writer.uint32(26).string(message.rootProofHex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCommitRootProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCommitRootProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rootProofHex = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCommitRootProof {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      rootProofHex: isSet(object.rootProofHex)
        ? globalThis.String(object.rootProofHex)
        : isSet(object.root_proof_hex)
        ? globalThis.String(object.root_proof_hex)
        : "",
    };
  },

  toJSON(message: MsgCommitRootProof): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.rootProofHex !== "") {
      obj.rootProofHex = message.rootProofHex;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCommitRootProof>, I>>(base?: I): MsgCommitRootProof {
    return MsgCommitRootProof.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCommitRootProof>, I>>(object: I): MsgCommitRootProof {
    const message = createBaseMsgCommitRootProof();
    message.owner = object.owner ?? "";
    message.sessionId = object.sessionId ?? "";
    message.rootProofHex = object.rootProofHex ?? "";
    return message;
  },
};

function createBaseMsgCommitRootProofResponse(): MsgCommitRootProofResponse {
  return {};
}

export const MsgCommitRootProofResponse: MessageFns<MsgCommitRootProofResponse> = {
  encode(_: MsgCommitRootProofResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCommitRootProofResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCommitRootProofResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCommitRootProofResponse {
    return {};
  },

  toJSON(_: MsgCommitRootProofResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCommitRootProofResponse>, I>>(base?: I): MsgCommitRootProofResponse {
    return MsgCommitRootProofResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCommitRootProofResponse>, I>>(_: I): MsgCommitRootProofResponse {
    const message = createBaseMsgCommitRootProofResponse();
    return message;
  },
};

function createBaseMsgDistributeBatch(): MsgDistributeBatch {
  return { executor: "", sessionId: "", items: [] };
}

export const MsgDistributeBatch: MessageFns<MsgDistributeBatch> = {
  encode(message: MsgDistributeBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executor !== "") {
      writer.uint32(10).string(message.executor);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    for (const v of message.items) {
      DistributeItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDistributeBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDistributeBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items.push(DistributeItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDistributeBatch {
    return {
      executor: isSet(object.executor) ? globalThis.String(object.executor) : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => DistributeItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgDistributeBatch): unknown {
    const obj: any = {};
    if (message.executor !== "") {
      obj.executor = message.executor;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => DistributeItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDistributeBatch>, I>>(base?: I): MsgDistributeBatch {
    return MsgDistributeBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDistributeBatch>, I>>(object: I): MsgDistributeBatch {
    const message = createBaseMsgDistributeBatch();
    message.executor = object.executor ?? "";
    message.sessionId = object.sessionId ?? "";
    message.items = object.items?.map((e) => DistributeItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgDistributeBatchResponse(): MsgDistributeBatchResponse {
  return {};
}

export const MsgDistributeBatchResponse: MessageFns<MsgDistributeBatchResponse> = {
  encode(_: MsgDistributeBatchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDistributeBatchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDistributeBatchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDistributeBatchResponse {
    return {};
  },

  toJSON(_: MsgDistributeBatchResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDistributeBatchResponse>, I>>(base?: I): MsgDistributeBatchResponse {
    return MsgDistributeBatchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDistributeBatchResponse>, I>>(_: I): MsgDistributeBatchResponse {
    const message = createBaseMsgDistributeBatchResponse();
    return message;
  },
};

function createBaseMsgFinalizeAndCloseSession(): MsgFinalizeAndCloseSession {
  return { executor: "", sessionId: "", manifest: undefined };
}

export const MsgFinalizeAndCloseSession: MessageFns<MsgFinalizeAndCloseSession> = {
  encode(message: MsgFinalizeAndCloseSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executor !== "") {
      writer.uint32(10).string(message.executor);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.manifest !== undefined) {
      ManifestPacket.encode(message.manifest, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeAndCloseSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeAndCloseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.manifest = ManifestPacket.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFinalizeAndCloseSession {
    return {
      executor: isSet(object.executor) ? globalThis.String(object.executor) : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      manifest: isSet(object.manifest) ? ManifestPacket.fromJSON(object.manifest) : undefined,
    };
  },

  toJSON(message: MsgFinalizeAndCloseSession): unknown {
    const obj: any = {};
    if (message.executor !== "") {
      obj.executor = message.executor;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.manifest !== undefined) {
      obj.manifest = ManifestPacket.toJSON(message.manifest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeAndCloseSession>, I>>(base?: I): MsgFinalizeAndCloseSession {
    return MsgFinalizeAndCloseSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeAndCloseSession>, I>>(object: I): MsgFinalizeAndCloseSession {
    const message = createBaseMsgFinalizeAndCloseSession();
    message.executor = object.executor ?? "";
    message.sessionId = object.sessionId ?? "";
    message.manifest = (object.manifest !== undefined && object.manifest !== null)
      ? ManifestPacket.fromPartial(object.manifest)
      : undefined;
    return message;
  },
};

function createBaseMsgFinalizeAndCloseSessionResponse(): MsgFinalizeAndCloseSessionResponse {
  return {};
}

export const MsgFinalizeAndCloseSessionResponse: MessageFns<MsgFinalizeAndCloseSessionResponse> = {
  encode(_: MsgFinalizeAndCloseSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeAndCloseSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeAndCloseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFinalizeAndCloseSessionResponse {
    return {};
  },

  toJSON(_: MsgFinalizeAndCloseSessionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeAndCloseSessionResponse>, I>>(
    base?: I,
  ): MsgFinalizeAndCloseSessionResponse {
    return MsgFinalizeAndCloseSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeAndCloseSessionResponse>, I>>(
    _: I,
  ): MsgFinalizeAndCloseSessionResponse {
    const message = createBaseMsgFinalizeAndCloseSessionResponse();
    return message;
  },
};

function createBaseMsgAbortAndCloseSession(): MsgAbortAndCloseSession {
  return { executor: "", sessionId: "", reason: "" };
}

export const MsgAbortAndCloseSession: MessageFns<MsgAbortAndCloseSession> = {
  encode(message: MsgAbortAndCloseSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executor !== "") {
      writer.uint32(10).string(message.executor);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAbortAndCloseSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAbortAndCloseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAbortAndCloseSession {
    return {
      executor: isSet(object.executor) ? globalThis.String(object.executor) : "",
      sessionId: isSet(object.sessionId)
        ? globalThis.String(object.sessionId)
        : isSet(object.session_id)
        ? globalThis.String(object.session_id)
        : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgAbortAndCloseSession): unknown {
    const obj: any = {};
    if (message.executor !== "") {
      obj.executor = message.executor;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAbortAndCloseSession>, I>>(base?: I): MsgAbortAndCloseSession {
    return MsgAbortAndCloseSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAbortAndCloseSession>, I>>(object: I): MsgAbortAndCloseSession {
    const message = createBaseMsgAbortAndCloseSession();
    message.executor = object.executor ?? "";
    message.sessionId = object.sessionId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgAbortAndCloseSessionResponse(): MsgAbortAndCloseSessionResponse {
  return {};
}

export const MsgAbortAndCloseSessionResponse: MessageFns<MsgAbortAndCloseSessionResponse> = {
  encode(_: MsgAbortAndCloseSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAbortAndCloseSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAbortAndCloseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAbortAndCloseSessionResponse {
    return {};
  },

  toJSON(_: MsgAbortAndCloseSessionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAbortAndCloseSessionResponse>, I>>(base?: I): MsgAbortAndCloseSessionResponse {
    return MsgAbortAndCloseSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAbortAndCloseSessionResponse>, I>>(_: I): MsgAbortAndCloseSessionResponse {
    const message = createBaseMsgAbortAndCloseSessionResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  /** Step 1: Initialize a CSU session (creates session_id and returns session_upload_token for TUS/HTTP upload) */
  InitSession(request: MsgInitSession): Promise<MsgInitSessionResponse>;
  /** Step 2: Commit RootProof (computed from the extracted zip contents) */
  CommitRootProof(request: MsgCommitRootProof): Promise<MsgCommitRootProofResponse>;
  /** Step 3: Distribute fragments to FDSC (executor executes this via authz; signer is executor) */
  DistributeBatch(request: MsgDistributeBatch): Promise<MsgDistributeBatchResponse>;
  /** Step 4: Upload manifest to MDSC and close session on MDSC ACK (success path) */
  FinalizeAndCloseSession(request: MsgFinalizeAndCloseSession): Promise<MsgFinalizeAndCloseSessionResponse>;
  /** Abort session and close immediately (failure path) */
  AbortAndCloseSession(request: MsgAbortAndCloseSession): Promise<MsgAbortAndCloseSessionResponse>;
  /** Storage登録 (管理者のみ実行可能) */
  RegisterStorage(request: MsgRegisterStorage): Promise<MsgRegisterStorageResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
