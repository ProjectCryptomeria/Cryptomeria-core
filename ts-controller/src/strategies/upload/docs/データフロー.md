## 🔗 I/Oフローの全体像：データの変換と依存性の活用

アップロード戦略の実行は、入力データ（`Buffer`）を最終的な結果（`UploadResult`）に変換する、複数のモジュールを介したパイプラインとして機能します。

| ステップ | 実行主体 | 入力データ（I） | 出力データ（O） | 依存性の活用（DI） |
| :--- | :--- | :--- | :--- | :--- |
| **0. 実行開始** | `ExperimentRunner` | `data: Buffer`, `targetUrl: string` | N/A | `RunnerContext`全体 |
| **1. 共通準備** | `CompositeUploadStrategy` (ベースロジック利用) | `data: Buffer` | `allChunks: ChunkInfo[]` | `IGasEstimationStrategy`, `ChainManager` |
| **2. 割当決定** | `IChunkAllocator` | `allChunks: ChunkInfo[]` | `UploadJob[]` (Tx実行計画) | `ChainManager`, `ProgressManager`, `CommsStrategy` (Mempool監視用) |
| **3. Tx実行** | `IUploadTransmitter` (並列実行) | `UploadJob` (チャンクバッチ) | `ChunkLocation[]` (Tx成功の場所) | `ChainManager` (署名・ブロードキャスト), `IConfirmationStrategy` |
| **4. 最終登録** | `CompositeUploadStrategy` (ベースロジック利用) | `ChunkLocation[]` | `Manifest` (Metachainに保存) | `ChainManager` (Metachain Tx) |
| **5. 結果返却** | `CompositeUploadStrategy` | N/A | `UploadResult` | `PerformanceTracker` |

---

## 📦 各モジュールのI/Oとロジックフロー

戦略を構成する3つの主要モジュールについて、I/Oとロジックの責任範囲を詳細に定義します。

### 1. CompositeUploadStrategy (オーケストレーター)

**責務**: アップロードプロセスのライフサイクルを管理し、共通基盤、Allocator、Transmitterを適切なタイミングで呼び出す。

| I/O項目 | 内容 | ロジックフローでの役割 |
| :--- | :--- | :--- |
| **入力 (I)** | `RunnerContext`, `data: Buffer`, `targetUrl: string` | 外部からの実行指示。`RunnerContext`を通じてすべての依存オブジェクトにアクセスする。|
| **内部処理** | 1. `BaseCoreLogic.createChunks(data)`を実行。2. `BaseCoreLogic.estimateGas(...)`を実行。3. `IChunkAllocator`を呼び出し、`UploadJob[]`を取得。4. 取得したJobを並列処理し、各Jobに対して**`IUploadTransmitter`を呼び出す**。5. すべての`ChunkLocation[]`を集約。6. `BaseCoreLogic.registerManifest(...)`を実行。|
| **出力 (O)** | `UploadResult` (計測時間、Tx数、ガス使用量を含む集約された結果) | `PerformanceTracker`から最終結果を取得し、`ExperimentRunner`に返却する。|
| **重要な依存性**| `IChunkAllocator`, `IUploadTransmitter` (DI), `BaseCoreLogic` (継承または利用), `PerformanceTracker` (コンテキスト経由) |

---

### 2. IChunkAllocator (スケジューラー)

**責務**: チャンクのリストを受け取り、**どのチェーンに、どのようにグループ化して送るか**という実行計画を立てる。

| I/O項目 | 内容 | ロジックフローでの役割 |
| :--- | :--- | :--- |
| **入力 (I)** | `RunnerContext`, `allChunks: ChunkInfo[]` | チャンク化された生のデータリストと実行コンテキスト。|
| **内部処理**| 1. `context.currentTask.chainCount`に基づき、ターゲットチェーンを決定。2. **Mega\_Chunk**系では事前に静的分割を実行。3. **Common\_Queue**系（RR, Available）では、ループ内でチェーン選択ロジック（Mempool監視など）を実行しながらチャンクをバッチ化し、対応する`chainName`を設定する。|
| **出力 (O)**| `UploadJob[]` (ジョブリスト: `{ chainName: string, batch: ChunkBatch }[]`) | Transmitterが実行すべき「作業単位」と「送信先」を示す。|
| **重要な依存性**| **AvailableAllocatorのみ**: `CommunicationStrategy` (Mempool監視用RPC呼び出し), `ProgressManager` (バーのステータス更新) |

---

### 3. IUploadTransmitter (エグゼキューター)

**責務**: 1つのTx実行ジョブを受け取り、**Txの署名、送信、完了確認**という低レベルの処理を責任持って完了させる。

| I/O項目 | 内容 | ロジックフローでの役割 |
| :--- | :--- | :--- |
| **入力 (I)** | `RunnerContext`, `batch: ChunkBatch`, `chainName: string`, `estimatedGasLimit: string`, `bar: IProgressBar` | 実行コンテキストと、処理すべきチャンクのバッチ。|
| **内部処理**| 1. `ChainManager`から**`SigningStargateClient`**と**アカウント情報**を取得。2. **OneByOne**では`signAndBroadcast`で同期処理。3. **MultiBurst**では`ChainManager.incrementSequence()`でノンスを手動インクリメントし、`broadcastTx`で非同期送信。4. `MultiBurst`の場合、`IConfirmationStrategy`を呼び出して**完了確認を委譲**。5. `PerformanceTracker`にTxの結果を記録。|
| **出力 (O)**| `ChunkLocation[]` (成功したチャンクのインデックスとチェーン名) | Txが成功したことを証明し、マニフェスト登録に必要な情報を提供する。|
| **重要な依存性**| `ChainManager` (Txの実行), `IConfirmationStrategy` (MultiBurstの場合), `PerformanceTracker` (Tx結果の記録), `IProgressBar` (進捗更新) |

---

## 🔄 DIによるI/Oの委譲と再構成

この合成パターンにおいて、データの流れは**DIが保証するコントラクト（契約）**によってシームレスに連携します。

1.  **Compositeがバトンパス**: `CompositeUploadStrategy`は、`allChunks: ChunkInfo[]`を生成した後、そのデータの所有権をAllocatorに渡す代わりに、そのリスト全体と`RunnerContext`を渡して**Jobのリストという新しいI/O形式**を生成させます。
2.  **Transmitterの独立性**: `OneByOneTransmitter`も`MultiBurstTransmitter`も、**「自分の処理が完了すれば、Txの結果を`Tracker`に記録し、`ChunkLocation[]`を返す」**という単一の責務を持つため、どのAllocatorから呼ばれてもI/Oの整合性は保たれます。
3.  **ダウンストリームへの影響**: `IConfirmationStrategy`は、`IUploadTransmitter`の内部で呼び出される**さらに下流の依存モジュール**であり、`Transmitter`の実行結果を決定する重要な役割を担いますが、そのI/OはTxハッシュと`ConfirmationResult`のMapに限定されており、他のUploadモジュールに直接的な影響を与えません。