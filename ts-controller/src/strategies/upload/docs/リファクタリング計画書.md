# 📝 アップロード戦略リファクタリング手順書
この計画は、依存関係の深い順にステップを構成し、最終的に全ての実験ケースを**Compositeパターン**で網羅することを目指します。

## 🏁 ステージ 1: 構造のセットアップと契約の定義（基盤構築）

| Step | 目的 | 作成/修正ファイル | 留意点（I/Oと依存性） |
| :--- | :--- | :--- | :--- |
| **1-1** | 新しい論理構造を物理的に作成 | `upload/interfaces/`, `upload/base/`, `upload/implement/allocator/`, `upload/implement/transmitter/` | 既存のコードに影響を与えないよう、新しいディレクトリを作成します。 |
| **1-2** | 共通不変ロジックの分離 | `base/BaseCoreLogic.ts` (新規) | **I/O**: 入力なし / 出力はヘルパー関数。**既存ファイルから以下のロジックを移動・抽出**し、継承関係を解消します。\<ul\>\<li\>`createChunks` (チャンク化)\</li\>\<li\>`estimateGas` (ガス見積もり)\</li\>\<li\>`registerManifest` (マニフェスト登録)\</li\>\</ul\> |
| **1-3** | 可変モジュールの契約定義 | `interfaces/IChunkAllocator.ts`<br>`interfaces/IUploadTransmitter.ts` | **I/Oの明確化が最重要**：\<ul\>\<li\>**Allocator**: `(context, allChunks) -> UploadJob[]`\</li\>\<li\>**Transmitter**: `(context, batch, chainName, gasLimit, bar) -> ChunkLocation[]`\</li\>\</ul\> |
| **1-4** | 既存基底クラスの削除 | `BaseOneByOneStrategy.ts`<br>`BaseMultiBurstStrategy.ts` | 継承によるロジックの重複を防ぐため、この時点でこれらを削除します。ロジックは次のステージでTransmitterに移植します。 |

-----

# 🔧 ステージ 2: Transmitter（Tx実行方式）の実装（実行フローの定義）

| Step | 目的 | 作成ファイル | 留意点（ロジックの移植と依存性） |
| :--- | :--- | :--- | :--- |
| **2-1** | OneByOne実行方式の実装 | `implement/transmitter/OneByOneTransmitter.ts` | **[ロジック移植]** 旧 `BaseOneByOneStrategy.processChunkOneByOne`のロジックを移植。**依存性**: `RunnerContext.chainManager`を利用し、`signAndBroadcast('auto')`による同期実行を実装します。|
| **2-2** | MultiBurst実行方式の実装 | `implement/transmitter/MultiBurstTransmitter.ts` | **[ロジック移植]** 旧 `BaseMultiBurstStrategy`のTx署名/ブロードキャストロジックを移植。**依存性**: `RunnerContext.confirmationStrategy`を呼び出し、非同期送信後の完了確認を委譲します。シーケンス番号の手動インクリメントロジックもここに残します。 |

-----

# ⚙️ ステージ 3: Allocator（割当ロジック）の実装（スケジューリングの定義）

| Step | 目的 | 作成ファイル | 留意点（統合とI/O） |
| :--- | :--- | :--- | :--- |
| **3-1** | 静的割当ロジックの実装 | `implement/allocator/StaticMultiAllocator.ts` | **Single/Multi統合**：`chainCount`が1の場合も、単純な均等分割ロジックで対応できることを確認します。Mega\_Chunk戦略（S-1, S-3, M-1, M-2）をこのクラスに集約します。 |
| **3-2** | 巡回割当ロジックの実装 | `implement/allocator/RoundRobinAllocator.ts` | Common\_Queue（動的）のベースとなるロジック。Txの並列数とチェーンの割り当て順序を制御します。Single (S-2, S-4) は`chainCount: 1`として吸収されます。 |
| **3-3** | 動的空き選択ロジックの実装 | `implement/allocator/AvailableAllocator.ts` | **[ロジック移植]** 旧 `DistributeUploadStrategy.distributeAndProcessMultiBurst`および`findAvailableChain`のスケジューリングロジックを移植。**依存性**: `RunnerContext.communicationStrategy`を介してMempool監視用のRPCエンドポイントを利用します。|
| **3-4** | ランダム割当ロジックの実装 | `implement/allocator/RandomAllocator.ts` | ランダムなチェーン選択ロジックを実装します。 |

-----

# 🧪 ステージ 4: 合成とシステムへの統合（最終連携）

| Step | 目的 | 修正ファイル/削除ファイル | 留意点（最終確認） |
| :--- | :--- | :--- | :--- |
| **4-1** | 最終戦略クラスの作成と合成 | `implement/CompositeUploadStrategy.ts` | **I/O**: `IChunkAllocator`と`IUploadTransmitter`をDIで受け取ります。`execute`メソッド内で、TransmitterがJobを受け付けられる形式でAllocatorの出力を処理するオーケストレーションロジックを記述します。 |
| **4-2** | エクスポート設定の修正 | `upload/index.ts` | 外部からは\*\*`CompositeUploadStrategy`のみ\*\*を`export`し、内部実装であるAllocatorやTransmitterのクラスは隠蔽します。 |
| **4-3** | 戦略ファクトリの修正 | `controller/src/run-experiment.ts` | `instantiateStrategies`関数を修正します。新しい戦略名（例: `'StaticOneByOne'`, `'AvailableBurst'`など）を定義し、それぞれに対応するAllocatorとTransmitterの組み合わせを決定し、`CompositeUploadStrategy`に注入するロジックを実装します。 |
| **4-4** | 既存戦略クラスの削除 | `SequentialUploadStrategy.ts`<br>`DistributeUploadStrategy.ts` | これで全てのロジックが新しいモジュールに移行されたため、**既存の戦略クラスを完全に削除**し、リファクタリングを完了します。 |
