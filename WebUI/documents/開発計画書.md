かしこまりました。これまでの議論（Ver 5.0〜5.2）と、直近で再定義された「アップロードデータの構造」「Zipセキュリティ」「UI挙動」の仕様をすべて統合した、**RaidChain-WebUI 詳細要件定義書 (Ver 5.3)** の完全版を出力します。

---

# 📑 RaidChain-WebUI 詳細要件定義書 (Ver 5.3 - 最終統合版)

## 1. はじめに

### 1.1. 背景と目的
現在開発中の分散ストレージシステム「RaidChain」において、CLI（コマンドライン）ベースの操作は手順が複雑であり、実験条件の変更やリアルタイムな挙動の把握が困難である。
本プロジェクト「RaidChain-WebUI」は、**GUIによる直感的な統合管理環境**を提供することを目的とする。これにより、実験サイクルの高速化を実現するとともに、負荷分散や耐障害性といったシステムの挙動を視覚的に証明（デモンストレーション）可能な状態にする。

### 1.2. 想定ユーザー
* **システム開発者:** 実験条件（戦略、チェーン数など）を細かく調整し、定量的な性能評価データを収集する。
* **研究評価者:** デモンストレーションを通じて、自律分散システムの挙動を直感的に理解する。

---

## 2. システムアーキテクチャ

### 2.1. 全体構成 (3チェーンモデル)
本システムが管理するブロックチェーンネットワークは、以下の3種類のチェーンとリレイヤーで構成される。ユーザーとの接点（アカウント管理・決済）を**ControlChain**に一本化する設計とする。

1.  **ControlChain (司令塔・窓口):**
    * ユーザーアカウントを管理し、アップロード依頼を受け付ける唯一の窓口。
    * データの分割ロジック、および各DataChainへの保存指示（IBCパケット生成）を行うコントローラーロジックを内包する。
2.  **DataChain (倉庫):**
    * 実データの保存を担当する。負荷分散のため、設定に応じて複数台（例: 1～20台）が並列稼働する。
3.  **MetaChain (図書館):**
    * ファイルのマニフェスト（メタデータ：どの断片がどのチェーンにあるか）の管理を担当する。

### 2.2. 技術スタック

* **Frontend (SPA):**
    * Framework: **Vite + React + TypeScript**
    * UI Library: **Shadcn/UI**, Tailwind CSS
    * Visualization: Recharts (グラフ), React Flow (ネットワーク図), Xterm.js (ログ表示)
* **Backend (API Server):**
    * Runtime: **Node.js (v22+)**
    * Framework: **Hono** (REST API + WebSocketサーバー)
    * Database: **SQLite** + Prisma (実験設定、結果、ユーザー鍵の永続化)
    * Logic: 既存の `controller` (TypeScript) のロジックをサービス層として移植・統合
* **Infrastructure:**
    * Orchestration: **Kubernetes** (Minikube / Docker Desktop built-in K8s)
    * Container Runtime: Docker Engine (バックエンドからDockerソケット経由でビルド操作を行う)
    * Package Manager: **Helm** (RaidChainチャートのデプロイ)

---

## 3. 機能要件詳細

各機能はWebUI上の「レイヤー（画面/タブ）」として構成する。

### 3.1. デプロイレイヤー (Infrastructure Management)
**「ソースコードからのビルド」を含めた、ゼロからの環境構築機能。**

#### (1) イメージビルド機能
* **概要:** ソースコードの変更を反映させるため、WebUI上からDockerイメージの再ビルドを実行可能にする。
* **UI:** ビルド対象（Datachain / Metachain / Relayer / All）を選択するプルダウンと「ビルド」ボタン。
* **処理:** バックエンドがホストのDockerデーモンを操作し、ビルドを実行。ログはXterm.jsでリアルタイム表示する。

#### (2) 動的スケーリング & 一括デプロイ機能
* **概要:** システム全体の起動・停止と、DataChainの台数変更を行う。
* **UI:** DataChain数スライダー（範囲: 1～20）、デプロイボタン、リセット（全削除）ボタン。
* **処理:**
    1.  設定値を元に `helm install` を実行。
    2.  Kubernetes Jobにより、各チェーンのValidator/Relayer/Creator等の鍵（ニーモニック）を自動生成。
    3.  生成された鍵を使用し、各Podの初期化（Genesis設定）を行う。

### 3.2. アカウント・経済レイヤー (Account & Economy)
**「ユーザーはControlChainだけで完結する」UXの実現。**

#### (1) ユーザーアカウント管理
* **場所:** **ControlChain上のみ**に存在する。
* **機能:**
    * ユーザーの新規作成（鍵ペア生成）。
    * ユーザー一覧表示（アドレス、ControlChain上のトークン残高）。
    * 秘密鍵はバックエンドDBに暗号化して保存し、フロントエンドには表示しない（または表示オプションあり）。

#### (2) スマートFaucet (蛇口)
* **機能:** ユーザー一覧の「Faucet」ボタンを押下すると、システム内の**ControlChain上のMillionaireアカウント**から、対象ユーザーへトークンを送金する。
* **目的:** アップロード手数料（デポジット）を支払うための原資を提供する。

#### (3) Relayer Watchdog (裏方資金管理)
* **機能:** システムの安定稼働のため、Relayerのガス欠を防止するバックグラウンドプロセス。
* **ロジック:**
    * 全チェーン（Control, Data-N, Meta）の **Relayerアカウント残高** を常時監視する。
    * 残高が閾値を下回った場合、**そのチェーンのMillionaireアカウント** からRelayerへ自動送金を実行する。
* **UI:** 自動補給が発生した際、画面上にトースト通知（例:「Data-2のRelayerに資金を自動補給しました」）を表示する。

### 3.3. コントロールレイヤー (Experiment Control)
**実験条件の精密な制御と実行。既存のController機能をGUI化する。**

#### (1) 戦略設定 (Strategy Configuration)
実験の基本方針を設定する。
* **コントローラー種別:** ラジオボタンで選択。
    * `オンチェーンコントローラー` (Gateway/ControlChain経由)
    * `オフチェーンコントローラー` (クライアントが直接各チェーンへTx送信 ※従来互換)
* **Allocator (割当戦略):** プルダウン選択。
    * `Static` (静的均等割当)
    * `RoundRobin` (順次割当)
    * `Random` (ランダム割当)
    * `Available` (Mempool空き状況監視による動的割当 **※研究の核**)
* **Transmitter (送信戦略):** プルダウン選択。
    * `OneByOne` (逐次同期送信・確実性重視)
    * `MultiBurst` (並列バースト送信・速度重視)

#### (2) アップロード実行 & コスト試算

**A. 共通設定パラメーター**
* **使用DataChain選択:** 現在稼働中のDataChain一覧をチェックボックスリストで表示する。
    * チェックされたチェーンのみをアップロード対象とする。
    * この選択状態は**シナリオの一部として保存・復元可能**にする。

**B. データ構造とパス正規化ロジック (共通)**
アップロードされる全てのデータは、以下のルールに従って**「ルートディレクトリ名 ＝ プロジェクト名（ドメイン）」**となるフラットな相対パスリストに内部変換（正規化）される。
* **変換ルール:**
    * **フォルダアップロード:** 選択されたフォルダ名をルートとせず、ユーザーが設定した**プロジェクト名**をルートディレクトリとして再構築する。
    * **Zipアップロード:** 解凍後のルートディレクトリを**プロジェクト名**に置換する。
    * **単一ファイル:** `プロジェクト名/ファイル名` という構造に強制変換する。
    * **空ディレクトリ:** 無視する（Git準拠）。
* **変換例:**
    * 入力: `test-project/src/img.png`, プロジェクト名: `my-site.com`
    * 出力: `my-site.com/src/img.png`

**C. リアルアップロード (Real Upload)**
実際のファイル・ディレクトリをアップロードする機能。セキュリティ対策を最優先する。
* **対応フォーマット:** 単一ファイル / フォルダ（ドラッグ＆ドロップ） / Zipファイル
* **Zip処理のセキュリティ要件 (Zip Bomb対策):**
    1.  **非再帰的解凍:** Zip内のZipファイルは「バイナリファイル」として扱い、再帰的な解凍は行わない。
    2.  **ヘッダー事前チェック:** 解凍前にヘッダー情報を読み取り、展開後の総サイズが閾値（例: 20GB）を超える場合は即座に拒否する。
    3.  **ストリーム展開チェック:** ヘッダー改ざんの可能性を考慮し、展開処理をストリームで行う。展開済みデータの累積サイズを常時監視し、閾値を超えた瞬間に処理を中断・破棄する。
* **UI挙動:**
    * **プロジェクト名:** 選択したルートフォルダ名を初期値として入力（単一ファイルの場合は空欄）。変更時は内部パスも連動して変更される。
    * **データサイズ / ファイル数:** 解析結果を自動入力し、**編集不可（Read-only）**とする。
    * **チャンクサイズ:** システム推奨値（例: 4MiB）を初期値とし、編集可能とする。

**D. バーチャルアップロード (Virtual Upload)**
指定されたパラメータに基づき、メモリ上で「B. データ構造」を模倣したダミーデータを生成する。
* **生成ロジック:**
    * 指定された「ディレクトリ構造（階層深さ・フォルダあたりのファイル数）」に基づき、ランダムなパスリストを生成する。
    * ルートディレクトリ名は指定された「プロジェクト名」とする。
* **UI挙動:**
    * 各項目（プロジェクト名、データサイズ、ファイル数、チャンクサイズ等）はプレースホルダーのみ表示された**空欄（自由記述）**状態とする。
    * 「平均ファイルサイズ」は入力値から自動計算して表示する。

**E. コスト試算とデポジット**
* アップロード開始前に `simulate` を実行し、最大コスト（Max Gas）を算出する。
* ユーザーに**デポジット額（最大コスト）の承認**を求め、承認後にトークンをロックして処理を開始する。
* 処理完了後、確定した実費手数料との差額が返金（Unlock）されたことを通知する。

### 3.4. モニタリングレイヤー (Visualization)
**システムの挙動をリアルタイムで可視化し、論文や発表での説得力を高める。**

#### (1) アーキテクチャ・トポロジー図
* **ノード描画:** 現在稼働中の全ノード（Control, Data-N, Meta）をネットワーク図として描画する。
    * DataChainが停止している場合はグレーアウトする。
    * **スケーラビリティ対応:** 最大**20個**のDataChainが稼働しても、レイアウトが崩れず視認性を保つ設計とする（自動整列やズーム機能など）。
* **通信アニメーション:**
    * ノード間を**線（Line/Edge）**で接続する。
    * トランザクション発行やIBCパケット転送に合わせ、その線の中を**パケット（光の点）**が移動するアニメーションを表示する。

#### (2) Mempool リアルタイムグラフ
* 各DataChainのMempool滞留量（未処理Tx数）を棒グラフで横並びにリアルタイム表示する。
* `Available`戦略選択時に、混雑回避の様子を視覚的に証明する。

#### (3) ブロック生成モニター
* 各チェーンの最新ブロック高（Height）、直近のブロックに含まれたTx数をリスト表示する。

### 3.5. シナリオレイヤー (Analytics)
**実験の再現性とデータ収集を支援する。**

* **シナリオ保存・復元:**
    * 実験条件（戦略、**使用DataChainリスト**、Virtual/Real設定、各パラメータ）を「シナリオ」として名前を付けて保存し、後から設定を復元可能にする。
* **実験ログ:**
    * 実行ごとの**システムログ（コントローラーやチェーンの標準出力/エラー出力）**を個別に保存し、UI上で閲覧可能にする。
* **データ記録・エクスポート:**
    * 実行結果をDBに詳細に記録し、CSVまたはJSON形式でエクスポート可能にする。
    * **保存・出力項目:**
        * **実行ID** (UUID)
        * **シナリオ名**
        * **実行時タイムスタンプ**
        * **実行完了可否** (Success / Failed)
        * **シナリオ詳細:**
            * データサイズ (Bytes)
            * チャンクサイズ (Bytes)
            * **総Tx数**
            * アップロード方式（Allocator / Transmitter）
            * **使用したDatachain数**
            * **使用したDatachainのリスト**（例: "data-0, data-2"）
        * **パフォーマンス指標:**
            * アップロード時間 (ms)
            * ダウンロード時間 (ms)
            * スループット (bps)
            * 総ガス消費量

---

## 4. バックエンドAPIインターフェース定義 (Hono)

バックエンドはREST APIとWebSocketを適切に使い分ける。

### 4.1. インフラ管理 (Infrastructure)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `POST` | `/api/v1/infra/images/build` | Dockerイメージビルド開始 |
| `POST` | `/api/v1/infra/deployment` | システムデプロイ実行 |
| `DELETE`| `/api/v1/infra/deployment` | システム停止 |
| `PATCH` | `/api/v1/infra/scale` | DataChain数の変更 |
| `GET` | `/api/v1/infra/status` | 各Podの稼働状況取得 |
| `WS` | `/ws/infra/build-log` | **[WebSocket]** ビルドログ配信 |

### 4.2. アカウント・経済 (Account)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/accounts/users` | ユーザー一覧取得 |
| `POST` | `/api/v1/accounts/users` | 新規ユーザー作成 |
| `POST` | `/api/v1/accounts/faucet` | Faucet実行 |
| `GET` | `/api/v1/accounts/system` | システムアカウント残高一覧 |

### 4.3. 実験制御 (Experiment)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/experiments/strategies` | 利用可能な戦略リスト取得 |
| `GET` | `/api/v1/experiments/chains` | 稼働中のDataChain一覧取得 |
| `POST` | `/api/v1/experiments/estimate` | コスト・ガス代の試算 |
| `POST` | `/api/v1/experiments/upload/virtual` | Virtual Upload実験開始 |
| `POST` | `/api/v1/experiments/upload/real` | Real Upload実験開始 (Multipart) |
| `DELETE`| `/api/v1/experiments/running` | 実験強制停止 |

### 4.4. モニタリング & 分析 (Monitor)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/results` | 実験結果履歴一覧 |
| `GET` | `/api/v1/results/:id` | 実験結果詳細（ログ含む）取得 |
| `GET` | `/api/v1/results/:id/export` | 結果データのエクスポート |
| `GET` | `/api/v1/scenarios` | 保存済みシナリオ一覧 |
| `POST` | `/api/v1/scenarios` | シナリオ保存 |
| `WS` | `/ws/monitor/stream` | **[WebSocket]** 統合監視ストリーム |

---

## 5. 非機能要件

1.  **リアルタイム性:** ブロック生成やMempoolの状況は、WebSocketを用いて**1秒以内の遅延**でフロントエンドに反映させること。
2.  **レスポンス:** ビルドや大量データのアップロードなど、長時間要する処理は非同期ジョブとして実行し、UI操作をブロックしないこと。
3.  **データ永続性:** 開発環境の再起動に備え、SQLiteデータベースファイルは永続ボリュームに配置すること。
4.  **言語:** システムが出力するメッセージ、ログ、およびUI上の表示テキストは、極力**日本語**を使用すること。