# 📑 RaidChain-WebUI 詳細要件定義書 (Ver 1.0)

## 1. はじめに

### 1.1. 背景と目的
現在開発中の分散ストレージシステム「RaidChain」において、CLI（コマンドライン）ベースの操作は手順が複雑であり、実験条件の変更やリアルタイムな挙動の把握が困難である。
本プロジェクト「RaidChain-WebUI」は、**GUIによる直感的な統合管理環境**を提供することを目的とする。これにより、実験サイクルの高速化を実現するとともに、負荷分散や耐障害性といったシステムの挙動を視覚的に証明（デモンストレーション）可能な状態にする。

### 1.2. 想定ユーザー
* **システム開発者:** 実験条件（戦略、チェーン数など）を細かく調整し、定量的な性能評価データを収集する。
* **研究評価者:** デモンストレーションを通じて、自律分散システムの挙動を直感的に理解する。

---

## 2. システムアーキテクチャ

### 2.1. 全体構成 (3チェーンモデル)
本システムが管理するブロックチェーンネットワークは、以下の3種類のチェーンとリレイヤーで構成される。ユーザーとの接点（アカウント管理・決済）を**ControlChain**に一本化する設計とする。

1.  **ControlChain (司令塔・窓口):**
    * ユーザーアカウントを管理し、アップロード依頼を受け付ける唯一の窓口。
    * データの分割ロジック、および各DataChainへの保存指示（IBCパケット生成）を行うコントローラーロジックを内包する。
2.  **DataChain (倉庫):**
    * 実データの保存を担当する。負荷分散のため、設定に応じて複数台（例: 1～10台）が並列稼働する。
3.  **MetaChain (図書館):**
    * ファイルのマニフェスト（メタデータ：どの断片がどのチェーンにあるか）の管理を担当する。

### 2.2. 技術スタック

* **Frontend (SPA):**
    * Framework: **Vite + React + TypeScript**
    * UI Library: **Shadcn/UI**, Tailwind CSS
    * Visualization: Recharts (グラフ), React Flow (ネットワーク図), Xterm.js (ログ表示)
* **Backend (API Server):**
    * Runtime: **Node.js (v22+)**
    * Framework: **Hono** (REST API + WebSocketサーバー)
    * Database: **SQLite** + Prisma (実験設定、結果、ユーザー鍵の永続化)
    * Logic: 既存の `controller` (TypeScript) のロジックをサービス層として移植・統合
* **Infrastructure:**
    * Orchestration: **Kubernetes** (Minikube / Docker Desktop built-in K8s)
    * Container Runtime: Docker Engine (バックエンドからDockerソケット経由でビルド操作を行う)
    * Package Manager: **Helm** (RaidChainチャートのデプロイ)

---

## 3. 機能要件詳細

各機能はWebUI上の「レイヤー（画面/タブ）」として構成する。

### 3.1. デプロイレイヤー (Infrastructure Management)
**「ソースコードからのビルド」を含めた、ゼロからの環境構築機能。**

#### (1) イメージビルド機能
* **概要:** ソースコードの変更を反映させるため、WebUI上からDockerイメージの再ビルドを実行可能にする。
* **UI:** ビルド対象（Datachain / Metachain / Relayer / All）を選択するプルダウンと「Build」ボタン。
* **処理:** バックエンドがホストのDockerデーモンを操作し、ビルドを実行。ログはXterm.jsでリアルタイム表示する。

#### (2) 動的スケーリング & 一括デプロイ機能
* **概要:** システム全体の起動・停止と、DataChainの台数変更を行う。
* **UI:** DataChain数スライダー（範囲: 1～10）、Deployボタン、Reset（全削除）ボタン。
* **処理:**
    1.  設定値を元に `helm install` を実行。
    2.  Kubernetes Jobにより、各チェーンのValidator/Relayer/Creator等の鍵（ニーモニック）を自動生成。
    3.  生成された鍵を使用し、各Podの初期化（Genesis設定）を行う。

### 3.2. アカウント・経済レイヤー (Account & Economy)
**「ユーザーはControlChainだけで完結する」UXの実現。**

#### (1) ユーザーアカウント管理
* **場所:** **ControlChain上のみ**に存在する。
* **機能:**
    * ユーザーの新規作成（鍵ペア生成）。
    * ユーザー一覧表示（アドレス、ControlChain上のトークン残高）。
    * 秘密鍵はバックエンドDBに暗号化して保存し、フロントエンドには表示しない（または表示オプションあり）。

#### (2) スマートFaucet (蛇口)
* **機能:** ユーザー一覧の「Faucet」ボタンを押下すると、システム内の**ControlChain上のMillionaireアカウント**から、対象ユーザーへトークンを送金する。
* **目的:** アップロード手数料（デポジット）を支払うための原資を提供する。

#### (3) Relayer Watchdog (裏方資金管理)
* **機能:** システムの安定稼働のため、Relayerのガス欠を防止するバックグラウンドプロセス。
* **ロジック:**
    * 全チェーン（Control, Data-N, Meta）の **Relayerアカウント残高** を常時監視する。
    * 残高が閾値を下回った場合、**そのチェーンのMillionaireアカウント** からRelayerへ自動送金を実行する。
* **UI:** 自動補給が発生した際、画面上にトースト通知を表示する。

### 3.3. コントロールレイヤー (Experiment Control)
**実験条件の精密な制御と実行。既存のController機能をGUI化する。**

#### (1) 戦略設定 (Strategy Configuration)
実験の基本方針を設定する。
* **コントローラー種別:** ラジオボタンで選択。
    * `オンチェーンコントローラー` (Gateway/ControlChain経由)
    * `オフチェーンコントローラー` (クライアントが直接各チェーンへTx送信 ※従来互換)
* **Allocator (割当戦略):** プルダウン選択。
    * `Static` (静的均等割当)
    * `RoundRobin` (順次割当)
    * `Random` (ランダム割当)
    * `Available` (Mempool空き状況監視による動的割当 **※研究の核**)
* **Transmitter (送信戦略):** プルダウン選択。
    * `OneByOne` (逐次同期送信・確実性重視)
    * `MultiBurst` (並列バースト送信・速度重視)

#### (2) アップロード実行 & コスト試算
* **共通設定パラメーター:**
    * **使用DataChain選択:** 現在稼働中のDataChain一覧をチェックボックスリストで表示する。
        * チェックされたチェーンのみをアップロード対象とする。
        * この選択状態は**シナリオの一部として保存・復元可能**にする。
* **コスト試算とデポジット:**
    * アップロード開始前に `simulate` を実行し、最大コスト（Max Gas）を算出する。
    * ユーザーにデポジット額（最大コスト）の承認を求め、承認後にトークンをロックして処理を開始する。
    * 処理完了後、確定した実費手数料との差額が返金（Unlock）されたことを通知する。
* **Virtual Upload:**
    * **目的:** テストデータを仮想的に生成してアップロードする。
    * **UI挙動:** フォームはプレースホルダーが表示された**空欄（自由記述）**状態。
    * **設定項目:** アップロード名（ドメイン）、データサイズ、チャンクサイズ、ディレクトリ構造（階層深さ・ファイル数など）。
* **Real Upload:**
    * **目的:** 実際のファイル・ディレクトリをアップロードする。
    * **UI挙動:** ファイル選択後、データサイズ等は自動入力され**編集不可**となる。
    * **設定項目:** アップロード名、チャンクサイズ（編集可）。

### 3.4. モニタリングレイヤー (Visualization)
**システムの挙動をリアルタイムで可視化し、論文や発表での説得力を高める。**

#### (1) アーキテクチャ・トポロジー図
* **ノード描画:** 現在稼働中の全ノード（Control, Data-N, Meta）をネットワーク図として描画する。
    * DataChainが停止している場合はグレーアウトする。
    * **スケーラビリティ対応:** 最大**20個**のDataChainが稼働しても、レイアウトが崩れず視認性を保つ設計とする（自動整列やズーム機能など）。
* **通信アニメーション:**
    * ノード間を**線（Line/Edge）**で接続する。
    * トランザクション発行やIBCパケット転送に合わせ、その線の中を**パケット（光の点）**が移動するアニメーションを表示する。

#### (2) Mempool リアルタイムグラフ
* 各DataChainのMempool滞留量（未処理Tx数）を棒グラフで横並びにリアルタイム表示する。
* `Available`戦略選択時に、混雑回避の様子を視覚的に証明する。

#### (3) ブロック生成モニター
* 各チェーンの最新ブロック高（Height）、直近のブロックに含まれたTx数をリスト表示する。

### 3.5. シナリオレイヤー (Analytics)
**実験の再現性とデータ収集を支援する。**

* **シナリオ保存・復元:**
    * 実験条件（戦略、**使用DataChainリスト**、Virtual/Real設定、各パラメータ）を「シナリオ」として名前を付けて保存し、後から設定を復元可能にする。
* **実験ログ:**
    * 実行ごとの**システムログ（コントローラーやチェーンの出力）**を個別に保存し、UI上で閲覧可能にする。
* **データ記録・エクスポート:**
    * 実行結果をDBに詳細に記録し、CSVまたはJSON形式でエクスポート可能にする。
    * **保存・出力項目:**
        * **実行ID** (UUID)
        * **シナリオ名**
        * **実行時タイムスタンプ**
        * **実行完了可否** (Success / Failed)
        * **シナリオ詳細:**
            * データサイズ
            * チャンクサイズ
            * **総Tx数**
            * アップロード方式（Allocator / Transmitter）
            * **使用したDatachain数**
            * **使用したDatachainのリスト**（例: "data-0, data-2"）
        * **パフォーマンス指標:**
            * アップロード時間 (ms)
            * ダウンロード時間 (ms)
            * スループット (bps)

---

## 4. バックエンドAPIインターフェース定義 (Hono)

バックエンドはREST APIとWebSocketを適切に使い分ける。

### 4.1. インフラ管理 (Infrastructure)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `POST` | `/api/v1/infra/images/build` | Dockerイメージビルド開始 |
| `POST` | `/api/v1/infra/deployment` | システムデプロイ実行 |
| `DELETE`| `/api/v1/infra/deployment` | システム停止 |
| `PATCH` | `/api/v1/infra/scale` | DataChain数の変更 |
| `GET` | `/api/v1/infra/status` | 各Podの稼働状況取得 |
| `WS` | `/ws/infra/build-log` | **[WebSocket]** ビルドログ配信 |

### 4.2. アカウント・経済 (Account)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/accounts/users` | ユーザー一覧取得 |
| `POST` | `/api/v1/accounts/users` | 新規ユーザー作成 |
| `POST` | `/api/v1/accounts/faucet` | Faucet実行 |
| `GET` | `/api/v1/accounts/system` | システムアカウント残高一覧 |

### 4.3. 実験制御 (Experiment)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/experiments/strategies` | 利用可能な戦略リスト取得 |
| `GET` | `/api/v1/experiments/chains` | **[New]** 稼働中のDataChain一覧取得 |
| `POST` | `/api/v1/experiments/estimate` | コスト・ガス代の試算 |
| `POST` | `/api/v1/experiments/upload/virtual` | Virtual Upload実験開始 |
| `POST` | `/api/v1/experiments/upload/real` | Real Upload実験開始 |
| `DELETE`| `/api/v1/experiments/running` | 実験強制停止 |

### 4.4. モニタリング & 分析 (Monitor)
| Method | Endpoint | 概要 |
| :--- | :--- | :--- |
| `GET` | `/api/v1/results` | 実験結果履歴一覧 |
| `GET` | `/api/v1/results/:id/export` | 結果データのエクスポート |
| `GET` | `/api/v1/scenarios` | 保存済みシナリオ一覧 |
| `POST` | `/api/v1/scenarios` | シナリオ保存 |
| `WS` | `/ws/monitor/stream` | **[WebSocket]** 統合監視ストリーム |

---

## 5. 非機能要件

1.  **リアルタイム性:** ブロック生成やMempoolの状況は、WebSocketを用いて**1秒以内の遅延**でフロントエンドに反映させること。
2.  **レスポンス:** ビルドや大量データのアップロードなど、長時間要する処理は非同期ジョブとして実行し、UI操作をブロックしないこと。
3.  **データ永続性:** 開発環境の再起動に備え、SQLiteデータベースファイルは永続ボリュームに配置すること。
4.  **言語:** システムが出力するメッセージ、ログ、およびUI上の表示テキストは、極力**日本語**を使用すること。