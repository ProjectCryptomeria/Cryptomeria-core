# 📑 RaidChain-WebUI 詳細要件定義書 (Ver 1.0)

## 1\. はじめに

### 1.1 背景と目的

分散ストレージシステム「RaidChain」の研究開発において、CLIベースの複雑な操作（環境構築、実験実行、データ収集）を廃止し、**GUIによる直感的な統合管理環境**を提供する。
本システムにより、実験サイクルの高速化を実現するとともに、負荷分散や耐障害性といったシステムの挙動を視覚的に証明することを目的とする。

### 1.2 想定ユーザー

  * **システム開発者:** 実験条件を細かく調整し、定量的な性能評価データを収集する。
  * **研究評価者:** デモンストレーションを通じて、自律分散システムの挙動を直感的に理解する。

-----

## 2\. システムアーキテクチャ

### 2.1 全体構成 (3チェーンモデル)

本システムが管理するRaidChainネットワークは、以下の3種類のブロックチェーンとリレイヤーで構成される。**ControlChainとGatewayChainを統合**し、ユーザーとの接点を一本化している点が特徴である。

1.  **ControlChain (司令塔・窓口):**
      * ユーザーアカウントを管理し、アップロード依頼を受け付ける唯一の窓口。
      * データの分割ロジックと、各DataChainへの保存指示（IBCパケット生成）を担当する。
2.  **DataChain (倉庫):**
      * 実データの保存を担当。負荷分散のため複数台（例: 4台）が並列稼働する。
3.  **MetaChain (図書館):**
      * ファイルのマニフェスト（メタデータ）の管理を担当。

### 2.2 技術スタック

  * **Frontend (SPA):**
      * Vite + React + TypeScript
      * UI: Shadcn/UI, Tailwind CSS
      * Visualization: Recharts (グラフ), React Flow (ネットワーク図), Xterm.js (ログ)
  * **Backend (API Server):**
      * Runtime: Node.js (v20+)
      * Framework: **Hono** (REST + WebSocket)
      * Database: **SQLite** + Prisma (実験データ・ユーザー情報の永続化)
      * Logic: 既存の `controller` (TypeScript) を移植
  * **Infrastructure:**
      * Kubernetes (Minikube / Docker Desktop)
      * Docker Engine (ホスト側のDockerソケットをマウントして利用)

-----

## 3\. 機能要件詳細

### 3.1 デプロイレイヤー (Infrastructure Management)

**「ソースコードからのビルド」を含めた、ゼロからの環境構築機能。**

#### (1) イメージビルド

  * **機能:** 指定されたDockerfile（Datachain / Metachain / Relayer）を元にDockerイメージをビルドする。
  * **UI:** ターゲット選択プルダウンと「Build」ボタン。Xterm.jsによるビルドログのリアルタイム表示。
  * **裏側:** BackendがDockerソケット経由でホストのDockerデーモンを操作。

#### (2) 動的スケーリング & 一括デプロイ

  * **機能:** `DataChain` の稼働数（例: 1〜10）を設定し、システム全体を一括起動する。
  * **UI:** スケーリングスライダー、「Deploy / Reset」ボタン。
  * **裏側:** 設定値を元に `helm install` を実行。起動後、自動的にValidator/Relayer等の鍵生成と初期化を行う。

### 3.2 アカウント・経済レイヤー (Account & Economy)

**「ユーザーはControlChainだけで完結する」UXの実現。**

#### (1) ユーザーアカウント管理

  * **場所:** **ControlChain上のみ**。
  * **機能:** ユーザーの新規作成（鍵生成）、一覧表示、削除。
  * **データ:** 秘密鍵（ニーモニック）はBackendのSQLite（または暗号化ストレージ）で管理し、Frontendにはアドレスと残高のみを表示する。

#### (2) スマートFaucet (蛇口)

  * **機能:** ユーザーがボタンを押すと、**ControlChain上のMillionaireアカウント**からユーザーへトークンを送金する。
  * **制約:** ユーザーが明示的に受け取れるのはControlChainのトークンのみ。

#### (3) 裏方資金管理 (Relayer Watchdog)

  * **機能:** システム維持のための自動補給プロセス（バックグラウンド実行）。
  * **ロジック:**
      * 全チェーン（Control, Data-N, Meta）の **Relayerアカウント残高** を常時監視。
      * 残高が閾値を下回った場合、**そのチェーンのMillionaireアカウント** からRelayerへ自動送金する。
      * **UI:** 補給発生時にトースト通知を表示（例: "Auto-refilled Relayer on Data-2"）。

### 3.3 コントロールレイヤー (Experiment Control)

**実験条件の精密な制御と実行。**

#### (1) 戦略設定 (Strategy Configuration)

実験に使用するロジックをプルダウンで選択する。

  * **Allocator (割当):**
      * `Static` (静的均等)
      * `RoundRobin` (順次)
      * `Random` (ランダム)
      * `Available` (Mempool空き状況による動的割当 ※研究の核)
  * **Transmitter (送信):**
      * `OneByOne` (逐次同期送信)
      * `MultiBurst` (並列バースト送信)

#### (2) アップロード実行 & コスト試算

  * **コスト試算:** アップロード前に `simulate` APIを実行し、予測ガス代（トークン量）を提示。
  * **Virtual Upload:** 指定サイズ（例: 100MB）のダミーデータを生成して実験。
  * **Real Upload:** ローカルファイルをドラッグ＆ドロップでアップロード。

### 3.4 モニタリングレイヤー (Visualization)

**システムの挙動をリアルタイムで可視化・証明する。**

#### (1) アーキテクチャ図

  * 稼働中のノード構成（Control, Data-N, Meta）をネットワーク図として描画。
  * Tx発行やパケット転送に合わせてノード間を光が移動するアニメーションを表示。

#### (2) Mempool リアルタイムグラフ

  * 各DataChainのMempool滞留量（未処理Tx数）を棒グラフで横並び表示。
  * `Available` 戦略時に「混んでいるチェーンを避けている」様子を視覚的に証明する。

#### (3) システムアカウント監視パネル

  * 全チェーンの `Validator`, `Relayer`, `Millionaire` のアドレスと残高を一覧表示。
  * 残高不足時に警告色（赤）でアラート。

### 3.5 シナリオレイヤー (Analytics)

  * **シナリオ保存:** 実験設定（チェーン数、戦略、データサイズ）をプリセットとして保存。
  * **データ記録:** 実行ごとにタイムスタンプ、設定、結果（所要時間、スループット、総ガス量）をDBに保存。
  * **エクスポート:** 実験結果をCSV/JSON形式でダウンロード。

-----

## 4\. バックエンドAPIインターフェース定義

Backend (Hono) が提供するAPI仕様。
**REST API**（操作・設定系）と **WebSocket**（監視・ログ系）を使い分ける。

### 4.1 インフラ管理 (Infrastructure)

| Method | Endpoint | 処理内容 |
| :--- | :--- | :--- |
| **POST** | `/api/v1/infra/images/build` | イメージビルド開始 `{ targets: ['datachain', '...'] }` |
| **POST** | `/api/v1/infra/deployment` | 一括デプロイ実行 (Helm Install) |
| **PATCH** | `/api/v1/infra/deployment/scale` | スケーリング設定更新 `{ dataChainCount: 5 }` |
| **DELETE** | `/api/v1/infra/deployment` | システムリセット (全削除) |
| **GET** | `/api/v1/infra/status` | 各Podの稼働ステータス取得 |
| **WS** | `/ws/infra/build-log` | **[WS]** ビルドログのストリーミング配信 |

### 4.2 アカウント・経済 (Account)

| Method | Endpoint | 処理内容 |
| :--- | :--- | :--- |
| **GET** | `/api/v1/accounts/users` | ユーザー一覧取得（ControlChain残高含む） |
| **POST** | `/api/v1/accounts/users` | ユーザー新規作成 |
| **POST** | `/api/v1/accounts/faucet` | ユーザーへのFaucet実行 `{ userId, amount }` |
| **GET** | `/api/v1/accounts/system` | システムアカウント(Relayer等)の残高一覧取得 |

### 4.3 実験制御 (Experiment)

| Method | Endpoint | 処理内容 |
| :--- | :--- | :--- |
| **GET** | `/api/v1/experiments/strategies` | 利用可能な戦略リスト取得 |
| **POST** | `/api/v1/experiments/estimate` | コスト試算実行 (Simulation) |
| **POST** | `/api/v1/experiments/upload/virtual` | バーチャルアップロード開始 |
| **POST** | `/api/v1/experiments/upload/real` | リアルアップロード開始 (Multipart) |
| **DELETE** | `/api/v1/experiments/running` | 実行中の実験を強制停止 |

### 4.4 モニタリング & 分析 (Monitoring & Analytics)

| Method | Endpoint | 処理内容 |
| :--- | :--- | :--- |
| **GET** | `/api/v1/monitor/topology` | ノード構成情報の取得（図描画用） |
| **GET** | `/api/v1/scenarios` | 保存済みシナリオ一覧取得 |
| **POST** | `/api/v1/scenarios` | シナリオ保存 |
| **GET** | `/api/v1/results` | 過去の実験結果一覧取得 |
| **GET** | `/api/v1/results/:id/export` | 実験結果のCSV/JSONエクスポート |
| **WS** | `/ws/monitor/stream` | **[WS]** 統合監視ストリーム<br>・`BLOCK`: ブロック生成<br>・`MEMPOOL`: 負荷状況<br>・`RELAYER_ALARM`: 残高警告 |

-----

## 5\. 非機能要件

1.  **リアルタイム性:** WebSocketを使用し、ブロック生成やMempool状況を1秒以内の遅延で画面に反映すること。
2.  **レスポンス:** ビルドやアップロードなどの長時間処理中もUI操作をブロックしないこと（非同期ジョブ管理）。
3.  **データ永続性:** K8s再起動に備え、SQLiteファイルはPersistent Volume (PV) に配置すること。