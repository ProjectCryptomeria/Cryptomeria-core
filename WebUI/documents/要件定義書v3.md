ユーザー様より提供されたフロントエンドのソースコード（`ExperimentLayer.tsx`, `DeploymentLayer.tsx`など）および型定義（`types.ts`）を「正（Source of Truth）」とし、現在の実装ロジックに基づいた厳密な要件定義書を作成しました。

このドキュメントは、単なる機能リストではなく、\*\*「なぜそのUI/機能が存在するのか（設計意図）」**と**「フロントエンドが現在どのようなロジックで動作しているか」\*\*に重点を置いて再構成しています。

-----

# 📜 RaidChain WebUI 詳細要件定義書 (v3.0 - Frontend Driven)

## 1\. プロジェクト概要 & 目的

### 1.1. システムの定義

本システムは、分散ストレージブロックチェーン「RaidChain」の運用、実験、評価を行うための統合管理コンソールである。複雑なCLI操作（Kubernetes操作、トランザクション発行、ログ解析）をGUIに抽象化し、研究者や開発者が「実験シナリオの策定」と「結果の分析」に集中できる環境を提供する。

### 1.2. 現在の開発フェーズと位置付け

  * **現状**: フロントエンド主導開発フェーズ。UI/UXおよび実験フローのロジックはReact上で完成しており、バックエンド通信部分はモック（`services/mockData.ts`等）によってシミュレーションされている。
  * **方針**: 本要件定義書は、現在実装されているフロントエンドの挙動を「正」とし、将来的なバックエンド実装時のAPI仕様の基準とする。

-----

## 2\. システムアーキテクチャ・技術要件

### 2.1. フロントエンド技術スタック

  * **Framework**: React 18 + Vite
  * **Language**: TypeScript
  * **Styling**: Tailwind CSS (Utility-first CSSによる迅速なスタイリング)
  * **Visualization**: Recharts (グラフ描画), Lucide React (アイコン)
  * **State Management**: React Context/Hooksによるローカルステート管理（現在はRedux等は不使用）

### 2.2. グローバルステート要件

アプリケーション全体で共有・維持すべき状態（`App.tsx` レベルで管理）は以下の通り定義する。

| ステート名 | 型/構造 | 定義・役割 |
| :--- | :--- | :--- |
| `deployedNodeCount` | `number` | 現在クラスタ上に展開されているDataChainノードの数。トポロジー図やプルダウンの選択肢に影響する。 |
| `isDockerBuilt` | `boolean` | 最新のコードでDockerイメージがビルドされているか。デプロイ操作のガード条件となる。 |
| `users` | `UserAccount[]` | ユーザーアカウント情報（残高、アドレス、秘密鍵）。 |
| `activeExperiment` | `Object` | 現在実行中の実験ステータス。画面遷移しても実験進捗を保持するために必要。 |

-----

## 3\. 機能要件詳細 (Layer別)

### ① Monitoring Layer (リアルタイム監視)

**目的**: システム全体の健全性とデータフローを視覚的に把握し、ボトルネックを即座に検知する。

#### 3.1. ネットワークトポロジー可視化 (`TopologyGraph.tsx`)

  * **機能**: Control Chain, Meta Chain, Data Chain群の接続関係を描画する。
  * **設計意図**:
      * RaidChainのアーキテクチャ（Controlで分割 → Dataへ分散 → Metaへ記録）を直感的に理解させるため。
      * 静的な図ではなく、SVGアニメーション（パケット移動）を用いることで「稼働している実感」を与える。
  * **実装ロジック**:
      * Data Chainノード数に応じてSVGのキャンバス幅(`canvasWidth`)を動的に計算し、横スクロール可能にする。
      * 各ノードのステータス(`active/error`)に基づき、グロー効果の色（緑/赤）を変化させる。

#### 3.2. Mempool / ブロック生成モニター

  * **機能**: 各DataChainにおける未処理トランザクション（Mempool）の滞留数を棒グラフで表示。
  * **設計意図**:
      * 特定のシャード（DataChain）に負荷が偏っていないか（ホットスポット問題）を視覚的に発見するため。
  * **実装ロジック**:
      * 閾値（現在は150tx）を超えた場合、バーの色を警告色（赤）に変化させるアラート機能をUI側で実装。

-----

### ② Deployment Layer (インフラ管理)

**目的**: コマンドライン（kubectl, helm, docker）を使わずに、検証環境の構築・破棄を安全に行う。

#### 4.1. イメージビルド (`Docker Build`)

  * **機能**: DataChain, MetaChain, RelayerのDockerイメージビルドをエミュレートする。
  * **設計意図**:
      * デプロイ前に最新コードを反映させる工程を明示化し、デプロイミス（古いコードのデプロイ）を防ぐ。
  * **実装ロジック**:
      * 実行中フラグ(`isBuilding`)を立て、タイマー処理により擬似ログを出力。完了時に`isDockerBuilt = true`とする。

#### 4.2. クラスタスケーリング (`Cluster Scale`)

  * **機能**: スライダーによりノード数（1〜10）を指定し、Helm Upgradeを実行する。
  * **設計意図**:
      * ノード数変更によるスケーラビリティ実験を容易にするため。
  * **実装ロジック**:
      * **ガード条件**: `isDockerBuilt`がfalseの場合、デプロイボタンを非活性化し警告を表示する。
      * **完了処理**: 完了後、`deployedNodeCount`を更新し、Monitoring Layer等の表示に即座に反映させる。

#### 4.3. 環境リセット (`Reset`)

  * **機能**: 全てのPod, PVCを削除し、初期状態に戻す。
  * **設計意図**:
      * 実験の再現性を担保するため、環境をクリーンにする機能は必須である。
      * **破壊的操作への配慮**: モーダルダイアログを表示し、誤操作を防止する。

-----

### ③ Economy Layer (経済圏管理)

**目的**: ブロックチェーン実験に必要な「トークン（ガス代）」の管理と、システム維持のための資金供給を管理する。

#### 5.1. アカウント管理 & Faucet

  * **機能**: ユーザーアカウントの作成、削除、およびFaucet（資金供給）を行う。
  * **実装ロジック**:
      * **秘密鍵表示**: ユーザーのアドレスをクリック/ホバーした際、モーダルでMnemonicを表示する（デモ用に固定フレーズを使用）。
      * **システムアカウント**: RelayerやMillionaire（Faucet源泉）はシステムアカウントとして区別し、折りたたみ可能なUIに格納する。

#### 5.2. Relayer Watchdog (自動給付)

  * **機能**: Relayerの残高を監視し、閾値を下回った場合に自動で補充する機能のON/OFF。
  * **設計意図**:
      * 実験中にRelayerがガス欠を起こして実験が中断・失敗するのを防ぐため。
      * 実験者はアプリケーションロジックに集中すべきであり、インフラ維持（Relayerの残高管理）は自動化されるべきという思想。

-----

### ④ Experiment Layer (実験設定・実行)

**目的**: 複雑なパラメータの組み合わせ（Grid Search）を効率的に定義し、実験を実行・評価する。**本システムの最重要機能である。**

#### 6.1. データソース選択 (`Virtual` vs `Real`)

  * **Virtual Mode**:
      * **機能**: 指定サイズ(MB)のランダムバイナリを生成して送信する。
      * **意図**: 純粋なネットワークスループット（理論値）を計測するため、ディスクI/O等のボトルネックを排除したい場合に利用。
  * **Real Mode (Upload)**:
      * **機能**: ユーザーのローカルファイルをドラッグ＆ドロップで受け付ける。Zipファイルはブラウザ内で解凍（JSZip使用）し、構造を展開する。
      * **意図**: 実際のアプリケーション利用に近い形でのユーザビリティテストを行うため。
      * **実装ロジック**: ファイル構造を解析し、ASCIIアート風のツリー構造としてプレビュー表示する。

#### 6.2. パラメータの「範囲指定」とシナリオ生成

  * **機能**: データサイズやチャンクサイズに対し、「固定値」だけでなく「範囲（Start, End, Step）」を指定可能にする。
  * **設計意図**:
      * 研究において\*\*「どのパラメータが性能に影響を与えるか」\*\*を特定するには、パラメータをスイープ（変化）させた多数の実験が必要となる。手動で1つずつ設定するのは非効率であるため。
  * **実装ロジック (デカルト積生成)**:
      * 以下の要素の組み合わせ（直積）で実験シナリオ(`ExperimentScenario`)リストを自動生成する。
        1.  データサイズ配列 (Start〜End)
        2.  チャンクサイズ配列 (Start〜End)
        3.  選択されたAllocator戦略 (複数選択可)
        4.  選択されたTransmitter戦略 (複数選択可)
      * 例: データサイズ3通り × 戦略2通り = 6つのシナリオを一括生成。

#### 6.3. 事前コスト試算 (`Estimate`)

  * **機能**: シナリオ生成後、実行前に必要なトークンコストを計算し、ユーザー予算と比較する。
  * **設計意図**:
      * 長時間かかる実験が、途中で「残高不足」により失敗する手戻りを防ぐ（Fail Fast思想）。
  * **実装ロジック**:
      * 予算不足の場合、ステータスを初期段階で`FAIL`（Insufficient balance）とし、実行対象から除外する。

#### 6.4. 実験実行とログ (`Run`)

  * **機能**: `READY`状態のシナリオを順次実行(`RUNNING`)し、結果(`COMPLETE/FAIL`)を判定する。
  * **設計意図**:
      * 非同期プロセスを可視化し、ユーザーに安心感を与える。
  * **実装ロジック**:
      * 詳細ログはモーダルで表示。プログレスバーにより進捗を可視化。
      * 実行結果は`ExperimentResult`型として整形し、Library Layerへ引き渡す。

#### 6.5. プリセット管理 (Sidebar)

  * **機能**: 現在の設定値（範囲指定含む）を名前付きで保存・復元する。
  * **設計意図**:
      * 同じ条件での再実験（再現性確認）を容易にするため。
      * 複雑な範囲指定設定を毎回入力する手間を省くため。

-----

### ⑤ Library Layer (結果分析)

**目的**: 過去の実験データを蓄積し、比較・分析を行う。

  * **機能要件**:
      * 実験結果の一覧表示（ページネーション、ソート）。
      * 成功/失敗、使用した戦略によるフィルタリング。
      * CSV/JSON形式でのデータエクスポート（外部ツールでの分析用）。

-----

## 4\. データモデル定義 (`types.ts`準拠)

実装において以下のデータ型を厳守すること。

### 4.1. 戦略定義 (Enums)

拡張性を考慮し、Enumで定義する。

```typescript
// データのどのノードに割り当てるか
export enum AllocatorStrategy {
  STATIC = 'Static',          // 固定
  ROUND_ROBIN = 'RoundRobin', // 均等分散
  RANDOM = 'Random',          // ランダム
  AVAILABLE = 'Available',    // 空き容量重視 (Load Balance)
  HASH = 'Hash',              // コンテンツハッシュ
}

// データをどのように送信するか
export enum TransmitterStrategy {
  ONE_BY_ONE = 'OneByOne',    // 直列送信 (低負荷)
  MULTI_BURST = 'MultiBurst', // 並列送信 (高スループット)
}
```

### 4.2. 実験シナリオステータスフロー

シナリオの状態遷移は以下のように管理される。

1.  **PENDING**: シナリオ生成直後。
2.  **CALCULATING**: コスト試算中（非同期処理）。
3.  **READY**: 試算完了かつ予算内。実行待ち。
      * (分岐) **FAIL**: 予算不足、またはシステムエラー予測。
4.  **RUNNING**: 実験実行中。
5.  **COMPLETE**: 正常終了。

-----

## 5\. 今後のバックエンド実装への要求事項

現在のフロントエンドロジックを正として、バックエンド（Controller）は以下のAPIを提供する必要がある。

1.  **Scenario Execution API**:
      * フロントエンドから送られる「設定配列（シナリオのリスト）」を受け取り、順次実行するキューイングシステムを持つこと。
      * WebSocket等を用いて、リアルタイムに進捗とログをフロントエンドにプッシュすること。
2.  **Validation API**:
      * 実験実行前に「見積もりコスト」を返すエンドポイントを提供すること。
3.  **File Upload API**:
      * `Real Mode`において、ディレクトリ構造を保ったまま（またはZipで）ファイルを受け取り、バックエンド側で展開・解析する機能。

-----

## 6\. 補足：UI/UXデザイン指針

  * **色による意味付け**:
      * 🟢 **Emerald/Green**: 正常、Active、成功、コスト内。
      * 🔴 **Red/Rose**: エラー、停止、失敗、コスト超過、Mempool溢れ。
      * 🔵 **Indigo/Blue**: 情報、システム、Control Chain。
      * 🟠 **Orange/Amber**: 警告、Meta Chain、Preset保存。
  * **インタラクション**:
      * 破壊的操作（削除、リセット）は必ず確認モーダルを挟む。
      * 300msを超える処理には必ずLoadingインジケータを表示する。
      * パネルはリサイズ可能とし、作業領域をユーザーが調整できるようにする。