### 1\. チェーンロジックの実装 (Go / Cosmos SDK)

Scaffold（雛形）作成直後の状態から、具体的なビジネスロジックとIBC通信ロジックを実装する必要があります。

#### **A. GWC (Gateway Chain) - 送信側**

クライアントからのアップロードを受け付け、分割してパケットを飛ばす実装です。

1.  **Proto定義 (`proto/gwc/gateway/v1`)**

      * `tx.proto`: ユーザーがファイルを投げるための `MsgUpload` を定義します（ファイル名、データ本体などを引数に持つ）。
      * `packet.proto`: 他チェーンへ送るパケット構造体を定義します。
          * `FragmentPacket`: FDSCへ送るデータ断片（Binary, Index, TotalChunksなど）。
          * `ManifestPacket`: MDSCへ送る構成情報（Filename, ChunkMapなど）。

2.  **Keeperロジック (`x/gateway/keeper`)**

      * `msg_server.go`: `MsgUpload` を受け取った際の処理を実装します。
          * 入力データを分割（Sharding）するロジック。
          * IBCの `ChannelKeeper` を呼び出し、各FDSCへ `FragmentPacket` を送信するロジック。
          * MDSCへ `ManifestPacket` を送信するロジック。
      * **ルーティングロジック**: どのFDSC（Channel ID）にどのデータを送るか決定するロジック（ラウンドロビン等）を追加します。

#### **B. FDSC (FragmentData Storage Chain) - 受信側**

GWCから送られてきたデータ断片を保存する実装です。

1.  **Proto定義 (`proto/fdsc/datastore/v1`)**

      * `packet.proto`: GWCからの `FragmentPacket` を受信できるように定義を合わせます。

2.  **IBCモジュール (`x/datastore/module/module_ibc.go`)**

      * `OnRecvPacket`: パケットを受信した際に、中身を取り出して KVStore（`keeper.AppendFragment` 等）に保存する処理を実装します。現在はボイラープレート（空の実装）になっています。

#### **C. MDSC (ManifestData Storage Chain) - 受信側**

GWCから送られてきたマニフェストを保存する実装です。

1.  **Proto定義 (`proto/mdsc/metastore/v1`)**

      * `packet.proto`: GWCからの `ManifestPacket` を受信できるように定義を合わせます。

2.  **IBCモジュール (`x/metastore/module/module_ibc.go`)**

      * `OnRecvPacket`: パケットを受信した際に、マニフェスト情報を KVStore に保存する処理を実装します。

-----

### 2\. IBCリレイヤー設定の修正 (`scripts/init-relayer.sh`)

現在のスクリプトは「各データチェーンとメタチェーンを結ぶ（Stage 2想定）」構成になっているため、\*\*「GWCを中心に各チェーンを結ぶ（Stage 3想定）」\*\*トポロジーに変更する必要があります。

1.  **接続トポロジーの変更**

      * **現状:** `DATA_CHAIN_IDS` \<--\> `META_CHAIN_ID`
      * **修正後:**
          * `GWC` \<--\> `FDSC` (全てのFDSCに対してパスを作成)
          * `GWC` \<--\> `MDSC` (パスを作成)

2.  **ポート指定の修正**

      * `rly transact channel` コマンドで指定する `--src-port` と `--dst-port` を、各チェーンのモジュール名に合わせて修正します。
      * 例: GWC(`gateway`) -\> FDSC(`datastore`) の場合、src: `gateway`, dst: `datastore`。

-----

### 3\. オーケストレーションと起動スクリプト (`k8s/helm` & scripts)

Kubernetes上で正しい構成で起動するための修正です。

1.  **`scripts/entrypoint-chain.sh` の汎用化**

      * 現在は `CHAIN_APP_NAME` が `datachain` （または環境変数依存）になっていますが、`gwcd`, `mdscd`, `fdscd` という異なるバイナリ名、異なるホームディレクトリ構成に対応できるように微調整が必要になる可能性があります（Scaffoldの構成が統一されていればそのままでも動く可能性はあります）。

2.  **`values.yaml` (Helm) の構成変更**

      * Stage 3 の構成に合わせてレプリカ数やチェーン定義を変更します。
      * 例:
          * `gwc`: 1 replica (Gateway)
          * `mdsc`: 1 replica (Metastore)
          * `fdsc`: N replicas (Datastore) - スケーラビリティ実験のため複数台。

3.  **ジェネシス設定 (`genesis.json`)**

      * IBC通信を行うためには、各チェーンの `genesis.json` にてIBC機能（Capability等）が有効化されている必要があります（Scaffoldで自動生成される範囲で概ねOKですが、パラメータ調整が必要な場合があります）。

-----

### まとめ：優先的に着手すべきタスク

まずシステムを「疎通」させるための最短パスは以下の通りです。

1.  **GWCの実装**: `MsgUpload` を定義し、ダミーでもいいので「受け取ってログを出す」ところまで実装する。
2.  **IBC接続**: `init-relayer.sh` を書き換え、GWC-FDSC間のチャネルが開設できることを確認する。
3.  **パケット送信**: GWCのKeeperから固定のダミーパケットをFDSCへ送信し、FDSC側の `OnRecvPacket` でログが出ることを確認する。

これができれば、「GWCで受けてIBCで流す」というStage 3のコア部分の実証が可能になります。
