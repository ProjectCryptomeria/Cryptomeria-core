「GWC Keeper のコアロジック改修」を TDD（テスト駆動開発）で進めるための詳細な段階と、各段階で確認すべき項目およびそれを満たすためのテスト要件（Test Specification）をまとめました。

この計画は、まず**インターフェースの確定**を行い、次に**データのインプット処理**（Sharding/Zip解凍）、最後に**アウトプット処理**（分散/Manifest生成）へと進む、段階的かつリスクの低いアプローチを採用しています。

---

#📝 GWC Keeper コアロジック改修：TDD 実行計画##🎯 目標: Zipファイル一括アップロードとラウンドロビン分散の実現| 段階 | 目的 | 確認するべき項目 |
| --- | --- | --- |
| **フェーズ 0** | **Tx インターフェースの確定** | 新しい `MsgUpload` のフィールドが正しく定義され、巨大な Tx がバリデーションを通過すること。 |
| **フェーズ 1** | **基本 Sharding ロジックのリファクタリング** | ファイルデータが指定された `fragment_size` に基づいて、正確なバイト数で分割されること（Zip 解凍前の単一バイナリでのテスト）。 |
| **フェーズ 2** | **Zip 解凍と構造抽出の実装** | 圧縮ファイルから Web サイトの構造（ファイルパス、バイナリ）がインメモリで完全に再現されること。 |
| **フェーズ 3** | **ルーティングと Manifest の生成** | 複数の FDSC へのラウンドロビン分散が機能し、分散情報が MDSC へ送る Manifest に正確に記録されること。 |

---

##🔬 フェーズ 0: Tx インターフェースと環境の確定（`types/tx.proto`, `types/message_upload.go`）###目的`MsgUpload` のインターフェースを確定し、巨大な Tx を受け付けるための環境を整備します。これにより、Web UI 開発チームは新しい Tx 構造で開発を開始できます。

| 確認項目 | テスト要件 (Test Spec) |
| --- | --- |
| **0-1. 新規フィールドのバリデーション** | `project_name` が空文字列または禁止文字を含んでいた場合、Tx は `sdkerrors.ErrInvalidRequest` で失敗すること。 |
| **0-2. `fragment_size` の検証** | `fragment_size` が 0 またはシステム定義の最小値（例: 1024バイト）未満であった場合、エラーを返すこと。 |
| **0-3. 最大サイズ超過時のエラー** | メッセージのデータペイロード（Zipバイナリ）が、GWC の `MaxBytes` 制限を超えていた場合、Cosmos SDK の**ガバナンスレベル**で Tx が弾かれること（オンチェーンレベルではなく、SDKレベルのテストで確認）。 |

##🔬 フェーズ 1: 基本 Sharding ロジックのリファクタリング（`keeper/msg_server.go` - 内部関数）###目的既存または新規の Sharding ロジックを、新しく定義された `fragment_size` に対応し、綺麗でテスト可能な独立した関数（例: `splitDataIntoFragments(data, size)`）として切り出します。

| 確認項目 | テスト要件 (Test Spec) |
| --- | --- |
| **1-1. 正確なバイト数での分割** | `data` サイズが 50KB、`fragment_size` が 10KB の場合、**5つの断片**が生成され、各断片のサイズが正確に 10KB であること。 |
| **1-2. 端数処理（ラストチャンク）** | `data` サイズが 35KB、`fragment_size` が 10KB の場合、**4つの断片**が生成され、最後の断片のサイズが正確に 5KB であること。 |
| **1-3. 空データと最小サイズ** | 空データ (`[]byte{}`) や最小サイズ未満のデータを入力した場合、適切にエラーを返す、または単一の Fragment として処理されること。 |
| **1-4. チャンクインデックスの正確性** | 生成された Fragment に割り振られるインデックス（`index`）が 0 から順番に連番で割り振られていること。 |

##🔬 フェーズ 2: Zip 解凍と構造抽出の実装（`keeper/zip_logic.go`）###目的Zip 解凍のコア機能を実装し、Web サイトの階層構造を Manifest に変換する準備をします。Go の標準ライブラリ `archive/zip` を使用します。

| 確認項目 | テスト要件 (Test Spec) |
| --- | --- |
| **2-1. ファイルリストの完全性** | テスト用の Zip ファイル（例: `index.html`, `css/style.css`, `assets/logo.png` を含む）を入力として、**3つのエントリー**がパス付きで正確に抽出されること。 |
| **2-2. パス構造の維持** | 抽出されたファイルのエントリーが、`css/style.css` のように Zip 内の**階層パス**を正確に保持していること。 |
| **2-3. バイナリの一致** | 抽出された `assets/logo.png` のバイナリが、元の PNG ファイルのバイナリと完全に一致すること（ハッシュなどで検証）。 |
| **2-4. メモリ制限の強制** | Zip 解凍処理がカスタム関数でラップされ、事前に設定されたメモリ制限（例: 256MB）を超過した場合に、Go の Panic を回避し、**カスタムエラー**（例: `ErrMemoryLimitExceeded`）を適切に返すこと。 |
| **2-5. 圧縮形式の検証** | 壊れた Zip や非対応の圧縮形式（例: Tar/GZなど）を入力とした場合、Zip 処理ライブラリのエラーを捕捉し、ユーザーフレンドリーなエラーとして返すこと。 |

##🔬 フェーズ 3: ルーティングと Manifest 生成（`keeper/msg_server.go` - メインロジック）###目的Sharding された Fragment を複数の FDSC に振り分け、その結果を Manifest として MDSC に送る準備をします。

| 確認項目 | テスト要件 (Test Spec) |
| --- | --- |
| **3-1. FDSC チャネルの取得** | Keeper が依存性として持つ `ChannelKeeper` のモック/スタブを使い、有効な FDSC への IBC チャネル ID（例: `channel-0`, `channel-1`, `channel-2`）のリストを正確に取得できること。 |
| **3-2. ラウンドロビン分散の検証** | フェーズ 1 で生成した 10個の Fragment（`F0`〜`F9`）を、3つの FDSC（`C0`, `C1`, `C2`）に割り当てた場合、割り当て数が正確に **4:3:3** となること。 |
| **3-3. Manifest の正確な生成** | **Manifest** 構造体内に、Zip から抽出された全ファイルパスが含まれ、各ファイルの `fragments` リストが、正確な**リスト順**で `{"fdsc_id": "C0", "fragment_id": "..."}` のマッピングを保持していること。 |
| **3-4. IBC パケットの送信準備** | Manifest 送信用の IBC パケットが正確に生成され、MDSC への**単一**のパケット送信関数が呼び出されること。また、Fragment 送信用のパケットが、各 FDSC へのチャネルに対して**並列**で送信されるよう準備（またはモックの呼び出し）ができていること。 |
| **3-5. GWC の Pruning 実行** | `MsgUpload` の処理が正常終了した後、GWC のステート（KV Store）に、元の巨大なファイルデータ（ペイロード）のコピーが残っていないこと（**Strict Pruning**の運用に準拠していることをロジック内で確認）。 |