# ğŸ”Œ Cryptomeria Core Download Logic (Read Flow)

ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã¯ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚’å¤‰æ›´ã—ãªã„ãŸã‚ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ãªã**Queryï¼ˆå‚ç…§ï¼‰**ã¨ã—ã¦å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
GWCãŒãƒ—ãƒ­ã‚­ã‚·ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã®ã§ã¯ãªãã€**ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆCLI/Browserï¼‰ãŒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼**ã¨ãªã‚Šã€æƒ…å ±ã‚’é›†ç´„ãƒ»çµåˆã™ã‚‹ã€Œã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãƒ»ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã€ãƒ¢ãƒ‡ãƒ«ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚

## ğŸ”„ å‡¦ç†ãƒ•ãƒ­ãƒ¼æ¦‚è¦

1.  **Resolve (è§£æ±º)**: GWCã«å•ã„åˆã‚ã›ã¦ã€MDSC/FDSCã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã€‚
2.  **Fetch Manifest (åœ°å›³å–å¾—)**: MDSCã‹ã‚‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®**Manifest**ã‚’å–å¾—ã€‚
3.  **Parallel Fetch (ä¸¦åˆ—å–å¾—)**: Manifestã«åŸºã¥ãã€å„FDSCã‹ã‚‰**Fragment**ã‚’ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€‚
4.  **Reconstruct (å¾©å…ƒ)**: æ–­ç‰‡ã‚’çµåˆã—ã¦å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒãƒ»ä¿å­˜ã€‚

## ğŸ’» ã‚³ãƒ¼ãƒ‰è§£èª¬

### 1. ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®è§£æ±º
GWCã¯å„ãƒã‚§ãƒ¼ãƒ³ã¸ã®ãƒ«ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦æ©Ÿèƒ½ã—ã¦ãŠã‚Šã€å„ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒã‚§ãƒ¼ãƒ³ã®æ¥ç¶šæƒ…å ±ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

```go
// apps/gwc/x/gateway/client/cli/query_download.go

// GWCã«å•ã„åˆã‚ã›ã¦ã€è£ã«ã„ã‚‹ãƒã‚§ãƒ¼ãƒ³ã®APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
res, err := queryClient.StorageEndpoints(context.Background(), &types.QueryStorageEndpointsRequest{})

// ChainIDã‚„ChannelIDã‹ã‚‰URLã‚’å¼•ã‘ã‚‹ãƒãƒƒãƒ—ã‚’ä½œæˆ
endpointMap := make(map[string]string)
for _, info := range res.StorageInfos {
    endpointMap[info.ChainId] = info.ApiEndpoint
}
```

### 2. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆï¼ˆåœ°å›³ï¼‰ã®å–å¾—
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã‚’æŒ‡å®šã—ã¦MDSCã«å•ã„åˆã‚ã›ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹æˆæƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚
â€»ã“ã“ãŒWebãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°å¯¾å¿œã®ãŸã‚ã«ä¿®æ­£ã•ã‚ŒãŸé‡è¦ãƒã‚¤ãƒ³ãƒˆã§ã™ã€‚

```go
// apps/gwc/x/gateway/client/cli/query_download.go

// URLæ§‹ç¯‰: ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã€ã®ã¿
// GET /mdsc/metastore/v1/manifest/{project_name}
manifestUrl := fmt.Sprintf("%s/mdsc/metastore/v1/manifest/%s", mdscURL, projectName)

resp, _ := http.Get(manifestUrl)

// ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ç›®çš„ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®æƒ…å ±ã‚’æŠ½å‡º
// "files": { "images/logo.png": { "fragments": [...] } }
fileInfo, ok := mResp.Manifest.Files[filename]
```

### 3. ä¸¦åˆ—ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨çµåˆ (Reconstruction)
`goroutine` ã‚’ä½¿ç”¨ã—ã¦è¤‡æ•°ã®FDSCã‹ã‚‰åŒæ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€é«˜é€Ÿã«å¾©å…ƒã—ã¾ã™ã€‚

```go
// apps/gwc/x/gateway/client/cli/query_download.go

// æ–­ç‰‡ã®æ•°ã ã‘ä¸¦åˆ—å‡¦ç†ç”¨ã®é…åˆ—ã¨WaitGroupã‚’ç”¨æ„
chunks := make([][]byte, totalFragments)
var wg sync.WaitGroup

for i, frag := range fileInfo.Fragments {
    wg.Add(1)
    // ä¸¦åˆ—å®Ÿè¡Œ
    go func(idx int, fragID, fdscID string) {
        defer wg.Done()
        
        // A. ä¿ç®¡å ´æ‰€(FDSC)ã®URLã‚’ç‰¹å®š
        fdscURL := endpointMap[fdscID]
        
        // B. REST APIã§Fragmentãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        // GET /fdsc/datastore/v1/fragment/{fragment_id}
        fragUrl := fmt.Sprintf("%s/fdsc/datastore/v1/fragment/%s", fdscURL, fragID)
        
        // C. ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ (Base64 -> Binary)
        data := FetchAndDecode(fragUrl)

        // D. æ­£ã—ã„é †åºã§é…åˆ—ã«æ ¼ç´
        chunks[idx] = data
    }(i, frag.FragmentId, frag.FdscId)
}

// å…¨ã¦ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ã‚’å¾…æ©Ÿ
wg.Wait()

// 4. çµåˆã¨ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãå‡ºã—
outFile, _ := os.Create(outputPath)
for _, chunk := range chunks {
    outFile.Write(chunk)
}
```