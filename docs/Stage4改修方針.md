# Stage 4 改修方針 - PoC Finalization

本ドキュメントは、RaidChainのPoC（概念実証）を完遂させるための最終開発フェーズ「Stage 4」の技術的方針を定義する。
これまでの開発で判明した課題に対し、ブロックチェーンの制約（ブロックサイズ等）やリソース消費をあえて度外視し、**「Webブラウザから閲覧可能なオンチェーンWeb」**という体験を最短で実現するための現実的なアプローチを採用する。

## 1. ファイルアップロードの単一トランザクション化

### 現状の課題
現在はクライアントサイドでファイルを分割し、複数のトランザクションとして送信しているが、制御が複雑であり、UXが一般的なWebアップロードと乖離している。

### 改修方針
PoC環境（プライベートチェーン）におけるブロックサイズ制限を無視できる前提に立ち、**ファイルを分割せず、1つの巨大なバイナリとして送信する**方式へ変更する。

### 実装仕様
1.  **API Gateway**: GWCノードの前段（またはCosmos SDK RESTサーバー拡張）に、`multipart/form-data`を受け付ける簡易REST APIを設置する。
2.  **Tx作成**: APIサーバーは受信したファイルデータをペイロードとする単一の`MsgUpload`トランザクションを作成し、GWCへブロードキャストする。
3.  **メリット**: クライアントの実装コストを大幅に削減し、ユーザーはファイルを選択するだけでアップロードが可能となる。

## 2. Zipファイルによるディレクトリ構造のオンチェーン展開

### 現状の課題
ディレクトリ構造の維持には、クライアント側での複雑な解析と、メタデータチェーンへの緻密なマッピング登録が必要となっている。

### 改修方針
GWCのリソース消費（CPU/メモリ）を許容し、**GWC内部でZip解凍と展開を行う**ロジックを実装する。

### 実装仕様
1.  **アップロード**: ユーザーはフォルダをZip圧縮してアップロードする。
2.  **On-chain Logic**:
    * GWCの`MsgUpload`ハンドラ内で、Go標準ライブラリ`archive/zip`を用いてインメモリで解凍する。
    * 展開された各ファイルについて、ループ処理でフラグメント化とFDSCへの配送を行う。
    * MDSCへのマニフェスト登録時に、Zip内のパス構造をそのままファイルパスとして記録する。

## 3. ファイルアクセスとURL設計

### 現状の課題
REST APIのURLパスパラメータにファイルパス（例: `assets/logo.png`）を含めると、スラッシュ`/`が区切り文字として誤解釈され、ルーティングに支障をきたす。

### 改修方針
パスパラメータではなく、**クエリパラメータ**または**ワイルドカードルーティング**を採用し、可読性と技術的制約を両立させる。

### 実装仕様
* **推奨案**: クエリパラメータ方式
    * URL例: `http://raidchain.com/api/render?project=my-site&path=assets/logo.png`
    * メリット: URLエンコードのトラブルを最小限に抑えつつ、構造が人間にも理解しやすい。

## 4. FDSCへのラウンドロビン分散の実装

### 現状の課題
現在のGWC実装（`msg_server.go`）では、検出された最初のFDSCチャネルに対して全てのフラグメントを送信しており、負荷分散が行われていない。

### 改修方針
単純な**ラウンドロビン方式**を導入し、均等な分散を実現する。

### 実装仕様
1.  **チャネルリスト取得**: 利用可能な全FDSCのIBCチャネル一覧を配列として取得する。
2.  **ループ送信**: フラグメント送信ループ内で、インデックス`i`を用いて送信先を決定する。
    ```go
    targetChannel = fdscChannels[i % len(fdscChannels)]
    ```

## 5. GWCのWebサーバー化（Custom HTTP Handler）

### 現状の課題
現在はクライアントが能動的に断片を集める「オンデマンド方式」であり、ブラウザでURLを叩くだけではWebページが表示されない。

### 改修方針
GWCノードに**カスタムHTTPハンドラー**を実装し、GWC自体がWebサーバー（兼プロキシ）として振る舞う。

### 実装仕様
1.  **ハンドラー登録**: Cosmos SDKのAPIサーバーに `/render` エンドポイントを追加。
2.  **内部処理**:
    * **Resolve**: 内部でMDSCに問い合わせ、フラグメントの所在を特定。
    * **Fetch**: 各FDSCから並列でバイナリを収集。
    * **Merge**: メモリ上で結合し、元のファイルを復元。
3.  **レスポンス**: 復元したデータに適切な`Content-Type`（`text/html`等）を付与してHTTPレスポンスとして返却する。これにより、ブラウザは通常のWebページとして描画可能となる。