# ğŸ—ï¸ Cryptomeria Core Upload Logic (Write Flow)

Cryptomeria Coreã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¯ã€**ã€ŒGateway Chain (GWC) ã¸ã®ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆé€ä¿¡ã€**ã¨ã€ãã®å¾Œã®**ã€Œè‡ªå¾‹çš„ãªåˆ†æ•£å‡¦ç†ã€**ã«ã‚ˆã£ã¦æˆã‚Šç«‹ã£ã¦ã„ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è¤‡é›‘ãªåˆ†æ•£ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ„è­˜ã™ã‚‹ã“ã¨ãªãã€å˜ä¸€ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ã™ã‚‹ã ã‘ã§å®Œäº†ã—ã¾ã™ã€‚

## ğŸ”„ å‡¦ç†ãƒ•ãƒ­ãƒ¼æ¦‚è¦

1.  **Ingest (å—ä¿¡)**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ `MsgUpload` ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å—ä¿¡ã€‚
2.  **Unzip & Analyze (è§£æ)**: ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¡ãƒ¢ãƒªä¸Šã§è§£å‡ãƒ»å±•é–‹ã€‚
3.  **Sharding (åˆ†å‰²)**: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€å®šã‚µã‚¤ã‚ºï¼ˆChunkï¼‰ã«åˆ†å‰²ã€‚
4.  **Distribution (åˆ†æ•£)**: å„Chunkã‚’IBCãƒ‘ã‚±ãƒƒãƒˆã¨ã—ã¦è¤‡æ•°ã® **FDSC** ã¸ä¸¦åˆ—é€ä¿¡ã€‚
5.  **Indexing (ç›®éŒ²ä½œæˆ)**: å…¨ä½“ã®æ§‹æˆæƒ…å ±ã‚’ **Manifest** ã¨ã—ã¦ **MDSC** ã¸é€ä¿¡ã€‚

## ğŸ’» ã‚³ãƒ¼ãƒ‰è§£èª¬

### 1. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å—ä¿¡ã¨å‰å‡¦ç†
`MsgUpload` ã‚’ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã—ã€ãƒ‡ãƒ¼ã‚¿ã®æ­£è¦åŒ–ã‚„ZIPè§£å‡ã‚’è¡Œã„ã¾ã™ã€‚

```go
// apps/gwc/x/gateway/keeper/msg_server.go

func (k msgServer) Upload(goCtx context.Context, msg *types.MsgUpload) (*types.MsgUploadResponse, error) {
    ctx := sdk.UnwrapSDKContext(goCtx)

    // 1. å‰å‡¦ç†: ZIPãªã‚‰è§£å‡ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆã«å¤‰æ›
    //    å˜ä½“ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ãã®ã¾ã¾ãƒªã‚¹ãƒˆåŒ–
    objects, err := k.PreprocessUpload(ctx, msg)
    if err != nil {
        return nil, err
    }
    
    // 2. åˆ†æ•£å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ã¸å§”è­²
    if err := k.ProcessObjects(ctx, objects, msg.ProjectName, msg.Creator); err != nil {
        return nil, err
    }
    
    return &types.MsgUploadResponse{}, nil
}
```

### 2. åˆ†å‰²ã¨åˆ†æ•£ (Sharding & Distribution)
ã“ã“ãŒã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–­ç‰‡åŒ–ã—ã€ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ“ãƒ³æ–¹å¼ãªã©ã§ä¿å­˜å…ˆã®FDSCã‚’æ±ºå®šã—ã¦IBCãƒ‘ã‚±ãƒƒãƒˆã‚’é€ä¿¡ã—ã¾ã™ã€‚

```go
// apps/gwc/x/gateway/keeper/data_logic.go (Conceptual)

func (k Keeper) ProcessObjects(ctx sdk.Context, files []Object, projectName string, creator string) error {
    // ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆç”Ÿæˆç”¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
    fileManifests := make(map[string]FileMetadata)

    for _, file := range files {
        // A. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å›ºå®šã‚µã‚¤ã‚ºã§åˆ†å‰² (Sharding)
        chunks := SplitIntoChunks(file.Data) 
        var fragmentList []FragmentInfo

        for _, chunk := range chunks {
            // B. é€ä¿¡å…ˆã®FDSCã‚’é¸æŠ (Load Balancing)
            targetFdsc := k.SelectNextFdsc(ctx) 

            // C. Fragmentã‚’IBCãƒ‘ã‚±ãƒƒãƒˆã¨ã—ã¦é€ä¿¡ (GWC -> FDSC)
            //    ã“ã®å‡¦ç†ã¯éåŒæœŸã§è¡Œã‚ã‚Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®Txå¿œç­”ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“
            packet := types.NewFragmentPacketData(chunk.Data)
            k.TransmitIBCPacket(ctx, targetFdsc.ChannelID, packet)
            
            // D. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆç”¨ã«ã€Œã©ã“ã«é€ã£ãŸã‹ã€ã‚’è¨˜éŒ²
            fragmentList = append(fragmentList, FragmentInfo{
                FdscId:     targetFdsc.ChainID, // è§£æ±ºç”¨ã®ID
                FragmentId: GenerateHash(chunk.Data),
            })
        }
        
        // E. ãƒ•ã‚¡ã‚¤ãƒ«ã”ã¨ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ç™»éŒ²
        fileManifests[file.Path] = FileMetadata{
            Fragments: fragmentList,
            MimeType:  file.MimeType,
        }
    }

    // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆManifesté€ä¿¡ï¼‰ã¸
    return k.SendManifest(ctx, projectName, fileManifests)
}
```

### 3. ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆã®é€ä¿¡ (Indexing)
å…¨ã¦ã®Fragmenté€ä¿¡æ‰‹ç¶šããŒå®Œäº†ã—ãŸå¾Œã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã®åœ°å›³ï¼ˆManifestï¼‰ã‚’MDSCã¸é€ã‚Šã¾ã™ã€‚

```go
// apps/gwc/x/gateway/keeper/data_logic.go

func (k Keeper) SendManifest(ctx sdk.Context, projectName string, files map[string]FileMetadata) error {
    manifest := types.Manifest{
        ProjectName: projectName,
        Files:       files,
        Version:     "v1.0.0", // ç°¡æ˜“çš„ãªãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
    }

    // MDSCã¸ã®å°‚ç”¨ãƒãƒ£ãƒãƒ«ã‚’é€šã˜ã¦Manifestã‚’é€ä¿¡
    mdscChannel := k.GetMDSCChannel(ctx)
    packet := types.NewManifestPacketData(manifest)
    
    return k.TransmitIBCPacket(ctx, mdscChannel, packet)
}
```