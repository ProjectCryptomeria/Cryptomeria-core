# Stage 4 改修方針 - PoC Finalization

本ドキュメントは、RaidChainのPoC（概念実証）を完遂させるための最終開発フェーズ「Stage 4」の技術的方針を定義する。
これまでの開発で判明した課題に対し、ブロックチェーンの制約（ブロックサイズ等）やリソース消費をあえて度外視し、**「Webブラウザから閲覧可能なオンチェーンWeb」**という体験を最短で実現するための現実的なアプローチを採用する。

## 1. ファイルアップロードの単一トランザクション化

### 現状の課題
現在はクライアントサイドでファイルを分割し、複数のトランザクションとして送信しているが、制御が複雑であり、UXが一般的なWebアップロードと乖離している。

### 改修方針
PoC環境（プライベートチェーン）におけるブロックサイズ制限を無視できる前提に立ち、**ファイルを分割せず、1つの巨大なバイナリとして送信する**方式へ変更する。

### 実装仕様
1.  **API Gateway**: GWCノードの前段（またはCosmos SDK RESTサーバー拡張）に、`multipart/form-data`を受け付ける簡易REST APIを設置する。
2.  **Tx作成**: APIサーバーは受信したファイルデータをペイロードとする単一の`MsgUpload`トランザクションを作成し、GWCへブロードキャストする。
3.  **メリット**: クライアントの実装コストを大幅に削減し、ユーザーはファイルを選択するだけでアップロードが可能となる。

## 2. Zipファイルによるディレクトリ構造のオンチェーン展開

### 現状の課題
ディレクトリ構造の維持には、クライアント側での複雑な解析と、メタデータチェーンへの緻密なマッピング登録が必要となっている。

### 改修方針
GWCのリソース消費（CPU/メモリ）を許容し、**GWC内部でZip解凍と展開を行う**ロジックを実装する。

### 実装仕様
1.  **アップロード**: ユーザーはフォルダをZip圧縮してアップロードする。
2.  **On-chain Logic**:
    * GWCの`MsgUpload`ハンドラ内で、Go標準ライブラリ`archive/zip`を用いてインメモリで解凍する。
    * 展開された各ファイルについて、ループ処理でフラグメント化とFDSCへの配送を行う。
    * MDSCへのマニフェスト登録時に、Zip内のパス構造をそのままファイルパスとして記録する。

## 3. ファイルアクセスとURL設計

### 現状の課題
REST APIのURLパスパラメータにファイルパス（例: `assets/logo.png`）を含めると、スラッシュ`/`が区切り文字として誤解釈され、ルーティングに支障をきたす。

### 改修方針
パスパラメータではなく、**クエリパラメータ**または**ワイルドカードルーティング**を採用し、可読性と技術的制約を両立させる。

### 実装仕様
* **推奨案**: クエリパラメータ方式
    * URL例: `http://raidchain.com/api/render?project=my-site&path=assets/logo.png`
    * メリット: URLエンコードのトラブルを最小限に抑えつつ、構造が人間にも理解しやすい。

## 4. FDSCへのラウンドロビン分散の実装

### 現状の課題
現在のGWC実装（`msg_server.go`）では、検出された最初のFDSCチャネルに対して全てのフラグメントを送信しており、負荷分散が行われていない。

### 改修方針
単純な**ラウンドロビン方式**を導入し、均等な分散を実現する。

### 実装仕様
1.  **チャネルリスト取得**: 利用可能な全FDSCのIBCチャネル一覧を配列として取得する。
2.  **ループ送信**: フラグメント送信ループ内で、インデックス`i`を用いて送信先を決定する。
    ```go
    targetChannel = fdscChannels[i % len(fdscChannels)]
    ```

## 5. GWCのWebサーバー化（Custom HTTP Handler）

### 現状の課題
現在はクライアントが能動的に断片を集める「オンデマンド方式」であり、ブラウザでURLを叩くだけではWebページが表示されない。

### 改修方針
GWCノードに**カスタムHTTPハンドラー**を実装し、GWC自体がWebサーバー（兼プロキシ）として振る舞う。

### 実装仕様
1.  **ハンドラー登録**: Cosmos SDKのAPIサーバーに `/render` エンドポイントを追加。
2.  **内部処理**:
    * **Resolve**: 内部でMDSCに問い合わせ、フラグメントの所在を特定。
    * **Fetch**: 各FDSCから並列でバイナリを収集。
    * **Merge**: メモリ上で結合し、元のファイルを復元。
3.  **レスポンス**: 復元したデータに適切な`Content-Type`（`text/html`等）を付与してHTTPレスポンスとして返却する。これにより、ブラウザは通常のWebページとして描画可能となる。

---

# 📊 Stage 4 開発優先度定義 (機能重要度順)

「機能としての重要性（RaidchainがオンチェーンWebホスティングとして成立するかどうか）」という観点に基づき、開発の手間を度外視して優先順位を再定義しました。
「データの通り道を作る（基盤）」→「正しい構造でデータを入れる（入力）」→「データをWebとして見せる（出力）」→「品質を高める（最適化）」という、**データライフサイクル順**が最も手戻りが少なく、かつ機能の核心に早く到達できるルートです。

## 🥇 優先度 1: チェーン制約の解除とProto定義 (The Foundation)
**「これがないと始まらない」絶対的な前提条件です。**

* **タスク**:
    1.  ブロックサイズ（`MaxBytes`）およびガス制限（`MaxGas`）の大幅緩和。
    2.  `MsgUpload` 等のProto定義が、分割なしの巨大バイナリを受け入れ可能かの検証・修正。
* **機能的重要性**:
    * **巨大トランザクションの通過許可**: Stage 4の核心である「Zipファイル一括アップロード」は、現状のブロックチェーン設定（数MB制限）では物理的に不可能です。
    * **PoCの成立要件**: これをクリアしない限り、後続のZip解凍もWeb表示もすべて机上の空論となります。

## 🥈 優先度 2: Zipアップロードとオンチェーン解凍 (The Structure)
**「Webサイト」として機能させるための構造（ディレクトリ）を作る工程です。**

* **タスク**:
    1.  クライアントサイドの単一トランザクション化（Zip送信）。
    2.  GWCでの `archive/zip` を用いたインメモリ解凍と展開ロジックの実装。
    3.  MDSCへのマニフェスト登録時に、Zip内のパス構造（例: `css/style.css`）を維持して記録する改修。
* **機能的重要性**:
    * **ディレクトリ構造の担保**: Webサイトは単一のファイルではなく、複数のファイルがリンクし合って構成されます。Zip解凍ロジックこそが、ブロックチェーン上で「フォルダ階層」を再現する唯一の手段であり、これがなければ画像やCSSが正しく読み込まれる「Webサイト」になりません。
    * **UXの劇的改善**: ユーザーが「フォルダを圧縮して投げるだけ」というWeb 2.0的な体験を得られるようになります。

## 🥉 優先度 3: GWCのWebサーバー化 (The Experience)
**システムが「Webホスティング」であることを証明する、最大の価値提供（アウトプット）です。**

* **タスク**:
    1.  GWCへのカスタムHTTPハンドラー（`/render` 等）の実装。
    2.  URLクエリ等からのマニフェスト解決（Resolve）と、各FDSCからの並列フェッチ・結合（Restore）の実装。
    3.  適切な `Content-Type` を付与したブラウザへのレスポンス返却。
* **機能的重要性**:
    * **ブラウザ閲覧の実現**: これが実装されて初めて、専用クライアントツールを使わずに、一般のWebブラウザ（Chrome/Safari等）からURLを叩くだけでページが表示されるようになります。
    * **PoCのゴール**: 「オンチェーンWeb」というコンセプトが動く状態で可視化されるため、対外的なインパクトは最大です。ただし、表示するデータ（優先度2で作られる構造）がなければテストできないため、優先度は3番目となります。

## 🎖️ 優先度 4: ラウンドロビン分散の実装 (The Optimization)
**機能としては必須ですが、PoCの「体験」においては裏方の処理です。**

* **タスク**:
    1.  アクティブなFDSCチャネル一覧の取得と、ラウンドロビンによる送信先振り分け。
* **機能的重要性**:
    * **スケーラビリティの証明**: 「Raidchain」の名が示す通り、データを分散させること（RAID）はアーキテクチャ上のアイデンティティです。
    * **優先度が低い理由**: 極論、データが分散されず1つのFDSCに偏ったとしても、「Webサイトが見れる」というStage 4のユーザー体験自体は成立します。システムがダウンしない限り、後回しにしても「動くデモ」は作れます。

---

### まとめ：推奨実装フロー

この順序で実装することで、以下のように着実に機能が積み上がります。

1.  **優先度1**: 巨大なデータが通る「土管」が広がる。
2.  **優先度2**: その土管を通って「Webサイトの構造」がチェーン上に正しく保存される。
3.  **優先度3**: 保存された構造がブラウザで「閲覧」できるようになる。
4.  **優先度4**: 裏側でデータが綺麗に「分散」されるようになる。