# 要件定義書v3.2 - モジュラー型インターチェーンWEBホスティング

## 1. はじめに

### 1.1. 背景・目的

#### 1.1.1. 目的

本システムは、Cosmosエコシステムのモジュラー性を活用し、WEBリソースをブロックチェーン上に永続的に保存・配信する「オンチェーンWEB」システムのPoCを行うことにある。
従来のモノリシックなブロックチェーンストレージとは異なり、**「受付(Execution)」「管理(Metadata)」「保存(Storage)」**の役割を異なるチェーンに分離し、スケーラビリティとデータの永続性を両立させる。

#### 1.1.2. 背景

DAppsの普及に伴い、フロントエンドの永続性欠如（サーバーダウンやリンク切れ）が課題となっている。既存のオンチェーンストレージはコストや速度の面でWebホスティングには不向きであり、Internet Computerのような巨大な独自エコシステムは移植性に欠ける。
そこで本システムでは、Cosmos SDKとIBCを用いた「インターチェーン分散ファイルシステム」を構築し、軽量かつ汎用的なWebホスティング基盤を提案する。

### 1.2. システム概要

本システムは、3層のブロックチェーン群によって構成される分散ストレージネットワークである。
クライアント（ブラウザやアップローダー）に対しては`http://cryptomeria.com/<ProjectName>`のような統一されたインターフェースを提供しつつ、バックエンドではIBC通信を駆使してデータを分散管理する。

**アーキテクチャコンセプト:**

  * **Router (Gateway Chain):** データを通過させ、振り分ける「ルーター」。データを持たない。
  * **Index (ManifestData Storage Chain):** プロジェクトの構成情報とバージョンを管理する「目録」。
  * **Body (FragmentData Storage Chain):** 実データを保管する「倉庫」。

### 1.3. 用語定義

  * **GWC (Gateway Chain):**
      * クライアントからのデータを受け付け、分割(Sharding)し、IBCを通じて各チェーンへ配送するルーターチェーン。
      * **揮発性 (Ephemeral)** であり、トランザクション処理後にデータ本体（ペイロード）を保持しない（Strict Pruning運用）。
  * **MDSC (ManifestData Storage Chain):**
      * プロジェクトの構造、バージョン情報、各ファイルの保存場所（マッピング情報）を記録するチェーン。
      * ここで管理されるデータ構造を**Manifest**と呼ぶ。
      * データの**永続性 (Persistent)** を担保する（Archive運用）。
  * **FDSC (FragmentData Storage Chain):**
      * 分割されたバイナリデータ（実データ）をKey-Value形式で保存するストレージチェーン。
      * ここで管理されるデータ構造を**Fragment**と呼ぶ。
      * データの**永続性 (Persistent)** を担保する（Archive運用）。
  * **IBC (Inter-Blockchain Communication):**
      * 各チェーン間でデータや命令を伝達するための通信プロトコル。
  * **Project / Asset / EntryPoint:**
      * v2定義を踏襲。URLのパス構造やアップロード単位（ディレクトリ/ファイル）を規定する概念。

## 2. 基本要件

### 2.1. 利害関係者

  * **デプロイヤー（ホスト）:** コンテンツをアップロードするユーザー。
  * **ビューワー（クライアント）:** Webページを閲覧するユーザー（ブラウザ）。
  * **デベロッパー:** システム運用者。

### 2.2. システムのスコープ

  * **Scope In:**
      * HTTP/Tx経由でのWebリソースアップロード・分割・分散保存。
      * HTTPリクエストに対するリソースの復元・配信。
      * プロジェクト単位でのセマンティックバージョニング管理（例: 1.0.0 -> 1.0.1）。
  * **Scope Out:**
      * 物理削除（ブロックチェーンの特性上、論理削除またはバージョンアップによる参照切り替えのみとする）。
      * 動的コンテンツのサーバーサイド実行。

## 3. 機能要件

### 3.1. コンポーネント詳細定義

#### 3.1.1. GWC (Gateway Chain) - The Router

  * **役割:** Ingest (受信), Sharding (分割), Distribution (配送)
  * **挙動:**
      * クライアントから`MsgUpload`を受け取る。
      * 受け取ったファイルを固定サイズの**Fragment**（例: 1KB〜10KB）に分割する。
      * **To FDSC:** 各FragmentをIBCパケットとして並列送信する。
      * **To MDSC:** プロジェクト情報と「どのFragmentをどのFDSCへ送ったか」のマッピング情報（Manifest）をIBCパケットとして送信する。
      * **Pruning:** `pruning = "custom"`, `keep-recent = "100"` 等を設定し、過去のデータペイロードをステートに残さない。

#### 3.1.2. MDSC (ManifestData Storage Chain) - The Index

  * **役割:** Indexing, Versioning, Mapping
  * **挙動:**
      * GWCからの**Manifest**登録要求を受け付ける。
      * プロジェクト単位でバージョンを管理し、指定されたバージョン（例: "2.0.1-rc"）でManifestを保存する。
      * クライアントからの「Project XのバージョンY（または最新版）の構成は？」というクエリに応答する。
      * **Pruning:** `pruning = "nothing"` (Archive Node)。

#### 3.1.3. FDSC (FragmentData Storage Chain) - The Body

  * **役割:** Blob Storage
  * **挙動:**
      * GWCからの**Fragment**保存要求を受け付け、KVStoreに保存する。
      * シンプルな`FragmentID: Data`形式で保存し、ファイルの中身やプロジェクト構造については関知しない。
      * **Pruning:** `pruning = "nothing"` (Archive Node)。

### 3.2. データ処理フロー (Data Pipeline)

#### 3.2.1. アップロードフロー (Write)

**特徴:** GWCは「土管」として振る舞い、完了を待たずにIBCパケットを放流する。

| ステップ | 担当 | アクション | 通信方式 |
| :--- | :--- | :--- | :--- |
| **1. Ingest** | **クライアント** → **GWC** | ファイルデータを含むトランザクション(`MsgUpload`)を送信。 | gRPC / HTTP |
| **2. Sharding** | **GWC (Internal)** | 受信データをメモリ上で**Fragment**に分割する。 | On-chain Logic |
| **3. Distribution** | **GWC** → **FDSCs** | 分割したFragmentを各FDSCへIBCパケットとして**並列送信**する。 | IBC (Packet) |
| **4. Metadata Sync** | **GWC** → **MDSC** | プロジェクト構成情報(**Manifest**)をMDSCへ送信する。 | IBC (Packet) |
| **5. Persistence** | **FDSC / MDSC** | 各チェーンで受信データをコミット（保存）する。 | On-chain Logic |
| **6. Cleanup** | **GWC (Internal)** | 次のブロック生成またはPruningサイクルにて、ペイロードデータは破棄される。 | System |

#### 3.2.2. ダウンロード・閲覧フロー (Read)

**特徴:** クライアント（またはWeb Proxy）が能動的に情報を集めて結合する「オンデマンド方式」。

| ステップ | 担当 | アクション |
| :--- | :--- | :--- |
| **1. Resolve** | **クライアント** → **MDSC** | URL（Project/Version/File）に基づき、対象の**Manifest**を問い合わせる。<br>※バージョン省略時は最新版のManifestを取得。 |
| **2. Map Response** | **MDSC** → **クライアント** | ファイルを構成するFragmentのリスト（保存先チェーンとID）を返す。 |
| **3. Fetch** | **クライアント** → **FDSCs** | マップの**リスト順**に基づき、必要なFDSCに対して**並列**にFragment取得リクエストを投げる。 |
| **4. Restore** | **クライアント** | 取得したFragmentをリスト順に結合・復元し、ブラウザに表示する。 |

### 3.3. データ構造要件

#### 3.3.1. MDSC (ManifestData)

MDSCに保存するデータ構造を**Manifest**と呼ぶ。
Manifestはプロジェクト全体のスナップショットを表す。`fragments`フィールドはファイルの先頭から末尾に向かって分割された順序通りに格納された配列（リスト）であり、復元時はこのリストを順番に結合することで元のファイルが得られる。

```json
{
  "project_name": "example.com",
  "version": "2.0.1-rc",
  "files": {
    "index.html": {
      "mime_type": "text/html",
      "size": 1024,
      "fragments": [
        { "fdsc_id": "chain-1", "fragment_id": "hash_a_1" },
        { "fdsc_id": "chain-2", "fragment_id": "hash_a_2" },
        { "fdsc_id": "chain-1", "fragment_id": "hash_a_3" },
        { "fdsc_id": "chain-2", "fragment_id": "hash_a_4" }
      ]
    },
    "assets/logo.png": {
      "mime_type": "image/png",
      "size": 5000,
      "fragments": [
        { "fdsc_id": "chain-1", "fragment_id": "hash_b_1" },
        { "fdsc_id": "chain-2", "fragment_id": "hash_b_2" },
        { "fdsc_id": "chain-3", "fragment_id": "hash_b_3" }
      ]
    }
  }
}
```

#### 3.3.2. FDSC (FragmentData)

FDSCに保存するデータ構造を**Fragment**と呼ぶ。
プロジェクトやファイル構造の文脈を持たない、純粋なバイナリ断片である。

```json
{
  "key": "chunk_id_hash_a_1",
  "value": "base64_encoded_binary_data..."
}
```

## 4. 非機能要件

### 4.1. 拡張性・可用性

  * **ストレージ拡張:** FDSCの台数を増やすことで、システム全体のストレージ容量と帯域をリニアにスケールさせる。
  * **1-of-N アーカイブ:** ネットワーク内に最低1台のアーカイブノード（MDSC/FDSC）が存在すればデータの完全性が保証されるモデルとする。

### 4.2. 運用・保守

  * **Pruning戦略:**
      * **GWC:** ディスク肥大化を防ぐため、アグレッシブなPruning設定（Keep Recent: 100等）を適用する。
      * **MDSC/FDSC:** データの永続性を保証するため、Pruning無効（Archive）設定を適用する。
  * **証跡管理:** GWCはデータを消去するため、アップロード証跡が必要な場合はGWCが発行するイベントログを外部インデクサで収集・保存する。

### 4.3. 性能

  * アップロード時のGWCにおけるボトルネック（メモリ、CPU）を監視し、Fragmentサイズや並列数の最適化を行う。
  * Web閲覧時のレイテンシ低減のため、クライアント（Proxy）側での並列フェッチ性能を重視する。

## 5. 制約条件

  * **Cosmos SDK:** 全チェーンはCosmos SDKを用いて構築する。
  * **IBC:** チェーン間通信はIBCに準拠する。
  * **言語:** コアロジックはGo言語で実装する。
  * **Web互換性:** 最終的なユーザー体験は標準的なWebブラウザで完結させる（専用ウォレット必須等の障壁を閲覧者には設けない）。