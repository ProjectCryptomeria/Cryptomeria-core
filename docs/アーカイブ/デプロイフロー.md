# Kubernetes リソースとHelmの基礎知識 & 本リポジトリでの活用

このデプロイフローを理解するために必要なKubernetes（K8s）の基本概念と、**Cryptomeriaプロジェクトでそれらが具体的にどう使われているか**を解説します。

### 📦 Helm (パッケージマネージャー)

  * **基本概念:** Kubernetesのマニフェスト（YAMLファイル）をテンプレート化し、変数を差し込むことで動的にリソースを生成・管理するツールです。「Chart」と呼ばれるパッケージ単位でアプリケーションをデプロイします。
  * **このリポジトリでの活用:**
      * **テンプレート化:** `apps/` 以下の複数のチェーン（FDSC, MDSC, GWC）を、1つの共通テンプレート（`chain-statefulset.yaml`）で管理しています。
      * **動的構成:** `just all-in-one chains=2` のようにコマンド引数でノード数を指定すると、Helmがその値をテンプレートに注入し、必要な数のノードを自動生成します。
      * **ライフサイクル管理:** `helm install/uninstall` コマンド一つで、関連するすべてのリソース（Service, ConfigMap, Podなど）を一括作成・削除します。

### 🛠 Helm Chart ファイル構成 & 仕組み解説

このリポジトリ (`ops/infra/k8s/helm/cryptomeria`) で使われている主要なファイルとその役割を解説します。

1.  **`Chart.yaml` (チャート定義)**

      * チャートのメタデータを記述するファイルです。Helmはこのファイルを読み込んでパッケージを認識します。

2.  **`values.yaml` (デフォルト設定値)**

      * テンプレートに埋め込む変数のデフォルト値を定義します。
      * `chains` リストで複数のチェーン（FDSC, MDSC, GWC）を定義し、ユーザーはコマンドライン引数でこれらの値を上書きしてデプロイします。

3.  **`templates/chain-statefulset.yaml` (StatefulSetテンプレート)**

      * ブロックチェーンノード本体を定義する最重要ファイルです。
      * `{{- range .Values.chains }}` ループでチェーンの数だけStatefulSetを生成し、`volumeClaimTemplates` で永続ストレージを割り当てます。

4.  **`templates/service.yaml` & `service-external.yaml` (Service定義)**

      * **Headless Service:** ロードバランシングを行わず、PodのIPアドレスリストを直接返します（P2P通信用）。
      * **ClusterIP / NodePort:** 外部からのRPCアクセス用です。

5.  **`templates/rbac.yaml` (権限設定)**

      * PodがK8s APIを操作する権限（RBAC）を定義します。
      * `job-mnemonic-generator` や `entrypoint-chain.sh` が `Secret` を操作するために必要です。

6.  **`templates/configmap.yaml` (設定・スクリプト)**

      * `entrypoint-chain.sh` などの初期化スクリプトをK8sオブジェクトとして管理し、Podにマウントします。

7.  **`templates/job-mnemonic-generator.yaml` (初期化ジョブ)**

      * Helm Hooks (`pre-install`) を使い、メインのStatefulSetが作られる**前**に実行され、共通鍵（Mnemonic）を生成します。

8.  **`templates/_helpers.tpl` (ヘルパー関数)**

      * リソース名の命名規則などを定義し、複数のYAMLファイルで再利用します。

### 🏢 StatefulSet (ステートフルセット)

  * **基本概念:** データベースやブロックチェーンのように「状態（データ）」を持つアプリケーションを管理するためのコントローラーです。
      * **不変のID:** Pod名が `pod-0`, `pod-1` のように連番で固定され、再起動しても名前が変わりません。
      * **永続ストレージ:** 各Podに専用のディスク（PVC）を紐付け、Podが消えてもデータ（ブロックチェーンの台帳）が消えないようにします。
  * **このリポジトリでの活用:**
      * **チェーンノードの本体:** 各ブロックチェーンノード（`fdsc-node-0` など）として使用されています。
      * **P2P通信の安定化:** ノードIDが固定されるため、ノード間でお互いを認識・接続する設定（Persistent Peers）が容易になります。

### 🔨 Job (ジョブ)

  * **基本概念:** 常駐するサーバーとは異なり、「一度だけ実行して、完了したら終了する」タスクを管理します。成功するまで再試行する機能などを持ちます。
  * **このリポジトリでの活用:**
      * **初期鍵生成 (`job-mnemonic-generator`):** デプロイの**最初の一回だけ**実行され、テストネット全体で共有する「秘密鍵の種（ニーモニック）」を生成します。
      * **Helm Hook:** `pre-install` フックを利用し、メインのチェーンノードが起動する**前**に必ずこのJobが完了するように制御されています。

### 📝 ConfigMap (コンフィグマップ)

  * **基本概念:** 設定ファイルやスクリプトをK8sリソースとして保存し、Podにファイルとしてマウント（注入）する機能です。これにより、Dockerイメージを作り直さずに設定や動作を変更できます。
  * **このリポジトリでの活用:**
      * **スクリプトの注入:** `entrypoint-chain.sh` などのシェルスクリプトをConfigMapとして管理しています。
      * **ロジックの分離:** チェーンの初期化ロジック（`init`, `gentx` 等）をGoバイナリやDockerイメージから切り出し、スクリプトとして外出しすることで、デプロイごとの挙動変更（デバッグモードのON/OFFなど）を容易にしています。

### 🔑 Secret (シークレット)

  * **基本概念:** パスワードや鍵などの機密情報をBase64エンコードして保存するリソースです。ConfigMapと似ていますが、セキュリティ用途で区別されます。
  * **このリポジトリでの活用:**
      * **鍵の共有:** Jobが生成したニーモニックをSecretに保存し、それをすべてのチェーンノードとRelayerがマウントして読み込むことで、**「全コンポーネントが同じウォレット操作権限を持つ」** 開発用環境を実現しています。

-----

# `just all-in-one` デプロイフロー詳細分析

このコマンドは大きく分けて **「ホスト側での準備・ビルドフェーズ」** と **「Kubernetesクラスタ内での起動フェーズ」** の2段階で進行します。

## Phase 1: ホスト側での実行プロセス (Justfile & Shell)

ターミナルで `just all-in-one` を実行すると、以下の順序でタスクが処理されます。

### 1\. 環境のクリーンアップ (`clean-k8s`)

古いデータや設定が残っていると競合するため、まずは既存のリソースを完全に削除します。

  * **Helm Uninstall:** `helm uninstall cryptomeria` を実行し、既存のReleaseを削除。
  * **PVC削除:** チェーンの永続データ（ブロックデータなど）を保持するPersistentVolumeClaimを削除。
  * **Namespace削除:** `cryptomeria` Namespaceごと削除し、更地に戻します。

### 2\. アーティファクトのビルド (`build-all`)

ここでは並列処理 (`[parallel]`) が行われ、各チェーン（fdsc, mdsc, gwc）とRelayerに対して以下の2ステップが実行されます。

1.  **バイナリのコンパイル (`build-chain`)**

      * Ignite CLI (`ignite chain build`) を使用して、Go言語のソースコードから実行バイナリ（例: `fdscd`）を生成します。
      * 生成物は `apps/<ターゲットチェーン>/dist/` ディレクトリに出力されます。

2.  **Dockerイメージのビルド (`build-image`)**

      * `docker build` コマンドが実行されます。
      * 前のステップで作成したバイナリをコンテナ内にコピーし、実行環境（Alpine Linux等）を含んだイメージ（例: `cryptomeria/fdsc:latest`）を作成します。

### 3\. デプロイ設定の動的生成 (`deploy`)

Helm Chartに渡す変数を、実行時の引数（`chains=2` など）に基づいて動的に生成します。

  * **スクリプト実行:** `ops/scripts/helm/generate-values.sh` が呼ばれます。
  * **Values生成:** このスクリプトは、「ノードをいくつ起動するか」などの構成情報を記述した一時ファイル（`.helm-temp-values.yaml`）を生成します。
      * 例: `replicas: 2` (StatefulSetのレプリカ数)

### 4\. Helm Install の実行

生成されたValuesファイルと、`ops/infra/k8s/helm/cryptomeria` にあるChartを使ってデプロイを実行します。

```bash
helm install cryptomeria ./ops/infra/k8s/helm/cryptomeria \
    --namespace cryptomeria \
    --create-namespace \
    -f .helm-temp-values.yaml
```

## Phase 2: Kubernetesクラスタ内での起動プロセス

Helm Installが成功すると、K8sクラスタ上で以下のリソースが作成され、Podの起動シーケンスが始まります。
ここでのスクリプト実行順序と依存関係が、システム全体の正常起動を左右します。

### 1\. 共通鍵の生成 (`job-mnemonic-generator`)

チェーンノードが起動する**前**に、すべてのチェーンとRelayerで共有する秘密鍵の種（Mnemonic）を生成します。

  * **リソース:** Kubernetes Job (`job-mnemonic-generator.yaml`)
  * **実行タイミング:** Helm Hook (`pre-install`, `pre-upgrade`) により、StatefulSetなどのメインリソースが作られる**直前**に実行されます。
  * **詳細動作解析:**
    1.  **環境構築:** `node:22-alpine` イメージ上で `kubectl` と `@cosmjs/proto-signing` をインストールします。
    2.  **ニーモニック生成:** Node.jsスクリプトを実行し、`DirectSecp256k1HdWallet` を使用して24単語のニーモニックを生成します。Cosmos SDK標準との互換性を確保しています。
    3.  **Secret作成:** 生成したニーモニックを含むK8s Secretマニフェスト（`kind: Secret`）を動的に作成します。
    4.  **適用:** コンテナ内部から `kubectl apply -f` を実行し、クラスタにSecret（例: `cryptomeria-mnemonics`）を登録します。

### 2\. チェーンノードの初期化 (`entrypoint-chain.sh`)

StatefulSetにより作成されたPod（例: `fdsc-node-0`）内で実行されます。これが**ブロックチェーンの命**となるプロセスです。

  * **リソース:** ConfigMapからマウントされ、コンテナの `entrypoint` として実行。

  * **実行タイミング:** Pod起動時。`pre-install` hookで作成されたSecretが `/etc/mnemonics/` にマウントされた状態で開始します。

  * **詳細動作解析:**

    #### A. 冪等性チェック (再起動対策)

    スクリプトは冒頭でデータディレクトリ（`$CHAIN_HOME/config`）の存在を確認します。

      * **存在する場合:** 初期化ステップをスキップして **C. 起動** へジャンプします。
      * **存在しない場合:** 初回起動とみなし、以下の **B. 初期構築** を実行します。

    #### B. チェーンの初期構築 (初回のみ)

    1.  **`init`:** `fdscd init` で設定ファイルを生成します。
    2.  **鍵のインポート (重要):**
          * マウントされたニーモニックファイルから、`validator`, `relayer`, `creator` の3つの鍵を復元します。
          * **HD Path指定:** TypeScript (CosmJS) クライアントと仕様を合わせるため、`m/44'/118'/0'/0/0` (Validator), `.../1` (Relayer), `.../2` (Creator) と**HD Pathを明示的に指定**しています。
    3.  **Genesisアカウント設定:**
          * 各アカウントに初期トークン（`uatom`）を割り当てます。
    4.  **Gentx生成と収集:**
          * 自身の署名付きGentxを作成し、`collect-gentxs` でGenesisファイルに取り込みます。
    5.  **設定ファイルのチューニング:**
          * `sed` コマンドで `config.toml`, `app.toml` を直接書き換えます。
          * **CORS:** `*` (全許可)
          * **通信制限緩和:** `max_body_bytes`, `max_tx_bytes` などを約10GBに設定し、大容量データのやり取りを許可。
          * **Mempool:** サイズを50,000に拡張。
          * **API/gRPC:** 外部アクセス (`0.0.0.0`) を有効化。

    #### C. ブロックチェーンの開始 (`start`)

    初期化完了後、プロセスを常駐させます。

      * **開発モード (`DEV_MODE=true`):** プロセスが終了しても自動的に再起動するループ内で実行されます（ホットリロード対応）。
      * **本番モード:** `exec` コマンドでプロセスをPID 1として置き換えます。

### 3\. IBCリレーイヤーのセットアップ (`init-relayer.sh`)

チェーン間の通信（IBC）を確立し、さらにシステム固有の初期設定を行うスクリプトです。

  * **リソース:** Relayer用Deploymentのエントリーポイント。
  * **実行タイミング:** チェーンと同時にPodは作成されますが、スクリプト内のロジックで**チェーンの準備完了を待機**します。
  * **詳細動作解析:**
    1.  **初期設定:** `rly config init` で設定を初期化し、各チェーン（GWC, MDSC, FDSC）の設定ファイル（JSON）を動的に生成して追加します。接続先にはK8sのHeadless Service (`svc.cluster.local`) を使用します。
    2.  **鍵の復元:** 共通ニーモニックを使用してRelayer用の鍵を復元します。
          * **特徴:** GWCチェーンに対しては、`rly` だけでなくローカルの `gwcd` コマンド用キーリングにも鍵をインポートします（後のトランザクション送信のため）。
    3.  **待機ループ:**
          * 各チェーンのRPCエンドポイントをポーリングし、ブロック高（Height）が **5以上** になるまで待機します。これにより、IBC接続に必要な「過去のブロックヘッダ」が存在する状態を保証します。
    4.  **IBC接続の確立 (Parallel Linking):**
          * クライアント、コネクション、チャネルの作成 (`rly transact ...`) を並列バックグラウンド処理で実行します。
          * 各ステップには `retry` 関数が適用されており、一時的なネットワークエラーなどで失敗しても最大30回リトライします。
    5.  **ストレージエンドポイントの自動登録:**
          * システム固有の動作です。Relayerコンテナ内にインストールされた `gwcd` コマンドを使用します。
          * `gwcd tx gateway register-storage` トランザクションを発行し、MDSCやFDSCのAPIエンドポイント情報をGWCチェーン上のスマートコントラクト（またはモジュール）に登録します。
    6.  **Relayer起動:**
          * 全てのセットアップ完了後、`rly start` でパケット中継プロセスを開始します。

## まとめ: 起動完了までのタイムライン

1.  **User:** `just all-in-one` を入力
2.  **Local:** ビルド完了 (`build-chain`, `build-image`)
3.  **Local:** HelmでK8sにマニフェスト送信 (`helm install`)
4.  **K8s (Hook):** `job-mnemonic-generator` が走り、**Secret（鍵）を作成**して終了。
5.  **K8s:** 各StatefulSetとRelayer DeploymentがPodを作成開始。
6.  **Chain Pod:** `entrypoint-chain.sh` がSecretを読み込み、**Genesis作成・初期化・プロセス起動**。
7.  **Relayer Pod:** `init-relayer.sh` が起動するが、チェーンのブロック高が5になるまで待機ループ。
8.  **Chain Pod:** ブロック生成が進む (Height: 1 -\> 2 -\> ... -\> 5)。
9.  **Relayer Pod:** 待機解除。**IBC接続（Link）を確立**し、**ストレージ登録Tx** を送信。
10. **Result:** 全チェーンが連携し、アプリケーションとして利用可能な状態になる。