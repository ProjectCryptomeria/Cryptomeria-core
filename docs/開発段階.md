### 🗺️ 全体ロードマップ

以下の3段階は、プロジェクトを\*\*「PoC（概念実証）から実用的な分散ストレージへ」\*\*と進化させるための論理的なステップです。

| 段階 | テーマ | 目的 |
| :--- | :--- | :--- |
| **第一段階** | **基本機能の実装** | オフチェーンの**コントローラー**を実装し、大容量ファイルの分割・分散保存という中核要件を実現する。 |
| **第二段階** | **パフォーマンス最適化** | コントローラーに**動的ルーティング機能**を追加し、複数チェーンのリソースを効率的に利用する。 |
| **第三段階** | **分散化と自動化** | コントローラーの処理をチェーン自体に移譲し、**IBC**による自律的なチェーン間連携を実現する。 |

-----

### 🏗️ 【第一段階】ファイル分割と分散アップロード機能の実装

これは要件定義にある「コントローラー」を具体的に実装するステップです。現在のテストスクリプトは単一の短いデータを扱っていますが、これを実際のファイルに対応させます。

#### ✅ 実装方針：TypeScriptによるコントローラー開発

ユーザー設定に基づき、TypeScript (Node.js) を用いて、以下の機能を持つAPIサーバー（コントローラー）を開発します。

1.  **ファイル受付 (APIエンドポイント)**:

      * HTTPリクエストでアップロードしたいファイルと、公開URLを受け取ります。

2.  **ファイル分割 (チャンク化)**:

      * 受け取ったファイルを固定サイズ（例: 16KB）の「データ断片（チャンク）」に分割します。

3.  **並列アップロード**:

      * `values.yaml` で定義された複数の`datachain`（`data-0`, `data-1`...） に対し、各チャンクを並列でトランザクションとして送信します。
      * 各トランザクションが成功すると、`datachain`からデータ断片の`Index`が返却されます。

4.  **マニフェスト作成**:

      * 「どのファイル」が「どのデータ断片(`Index`)のリスト」で構成されているかを示す**マニフェストJSON**を作成します。

5.  **マニフェスト登録**:

      * 作成したマニフェストを、指定された公開URLに紐付けて`metachain`にトランザクションとして送信します。

<!-- end list -->

```typescript:controller-example.ts
// コントローラーの実装イメージ (疑似コード)
import { exec } from 'child_process';
import { splitFileIntoChunks } from './chunker';

// 1. APIサーバーを起動 (例: Express.js)
app.post('/upload', async (req, res) => {
    const { file, url } = req.body;
    
    // 2. ファイルをチャンクに分割
    const chunks = await splitFileIntoChunks(file);

    // 3. 各チャンクをdatachainに並列アップロード
    const chunkIndices = await Promise.all(
        chunks.map((chunk, i) => {
            const dataChainName = `data-${i % 2}`; // ラウンドロビンで分散
            return uploadToDataChain(dataChainName, chunk);
        })
    );

    // 4. マニフェストを作成
    const manifest = {
        filepath: file.name,
        chunk_list: { chunks: chunkIndices }
    };

    // 5. マニフェストをmetachainに登録
    await uploadToMetaChain(url, JSON.stringify(manifest));

    res.status(200).send({ message: 'Upload complete!', url });
});
```

-----

### 🚀 【第二段階】トランザクションの動的ルーティング

第一段階で実装したコントローラーを拡張し、よりスマートなアップロード機能を追加します。単純なラウンドロビン方式ではなく、各`datachain`のネットワーク状況を考慮します。

#### ✅ 実装方針：Mempool監視による負荷分散

コントローラーに、各`datachain`の**Mempool（保留中のトランザクションプール）のサイズを監視する**機能を追加します。

1.  **定期的な状態監視**:

      * コントローラーは、各`datachain`のRPCエンドポイント (`:26657`) に定期的にアクセスします。
      * `/num_unconfirmed_txs` エンドポイントをポーリングし、各チェーンの保留トランザクション数を取得します。

2.  **ルーティングロジック**:

      * チャンクをアップロードする際、コントローラーは最も保留トランザクション数が少ない（＝空いている）`datachain`を動的に選択します。
      * これにより、特定のチェーンに負荷が集中するのを避け、アップロード全体の処理時間を短縮することが期待できます。

<!-- end list -->

```typescript:controller-routing-example.ts
// 第二段階の機能追加イメージ (疑似コード)
class DataChainMonitor {
    private chainStatus: Map<string, number> = new Map();

    constructor(private chainEndpoints: string[]) {
        // 1. 定期的に各チェーンの保留TX数を取得
        setInterval(this.updateChainStatus.bind(this), 5000);
    }

    private async updateChainStatus() {
        for (const endpoint of this.chainEndpoints) {
            const res = await fetch(`${endpoint}/num_unconfirmed_txs`);
            const data = await res.json();
            this.chainStatus.set(endpoint, parseInt(data.result.n_txs, 10));
        }
    }

    // 2. 最も空いているチェーンを選択するロジック
    public getOptimalChain(): string {
        let optimalChain = this.chainEndpoints[0];
        let minTxs = Infinity;
        for (const [endpoint, txCount] of this.chainStatus.entries()) {
            if (txCount < minTxs) {
                minTxs = txCount;
                optimalChain = endpoint;
            }
        }
        return optimalChain;
    }
}
```

-----

### 🔗 【第三段階】処理のオンチェーン化とIBC活用

これはプロジェクトのアーキテクチャを大きく変革し、**コントローラーへの依存をなくす**最も挑戦的なステップです。オフチェーンの処理をチェーン上のロジック（スマートコントラクト/モジュール）に移譲し、チェーン間で自律的にデータ連携させます。

#### ✅ 実装方針：`metachain`を司令塔とするIBCワークフロー

クライアントからのリクエストをトリガーに、`metachain`が各`datachain`に必要な処理をIBCパケットで指示するモデルに変更します。

1.  **新しいトランザクションの定義**:

      * クライアントは、**マニフェストと全てのデータ断片**を1つのトランザクションとして`metachain`に送信します。

2.  **`metachain`の役割 (司令塔)**:

      * `metachain`のカスタムモジュール (`x/metastore`) は、このトランザクションを受け取ります。
      * まず、マニフェストを自身の台帳に「処理中」ステータスで保存します。
      * 次に、各データ断片をIBCパケットに含め、対応する`datachain`に送信します。

3.  **`datachain`の役割 (データストア)**:

      * `datachain`のカスタムモジュール (`x/datastore`) は、`metachain`からのIBCパケットを受信します。
      * パケット内のデータ断片を自身の台帳に保存します。
      * 保存が完了したら、成功した旨を伝える**Acknowledgement (応答) パケット**を`metachain`に返送します。

4.  **処理の完了**:

      * `metachain`は、全ての`datachain`から成功の応答パケットを受け取ると、マニフェストのステータスを「確定」に更新します。
      * もし一部の`datachain`からタイムアウトやエラーの応答があった場合は、トランザクション全体を失敗させるなどのエラーハンドリングロジックを実装します。

この段階の実現には、Cosmos SDKの知識を深め、`datachain`と`metachain`のGo言語で書かれたモジュール（特に`keeper`）に、IBCパケットの送受信とそれに応じた状態遷移のロジックを直接実装する必要があります。現在の`scaffold-chain.sh`でIBCモジュールの雛形は作成済みのため、これを拡張していく形になります。