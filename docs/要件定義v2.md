# 要件定義書v2 - モジュラーブロックチェーンWEBホスティング

## 1\. はじめに

### 1.1. 背景・目的

#### 1.1.1. 目的

本システムの目的は、テキストやバイナリといったWEBリソースをブロックチェーン上に永続的に保存してホスティングする「オンチェーンWEB」のPoCを行うことにある。
その際、リソースを断片化し、複数のブロックチェーンに分散して保存する仕組みを構築する。

この仕組みを「Cosmosエコシステム」を用いて構築し、「全てがブロックチェーンで完結する」システムの実現を目指す。

#### 1.1.2. 背景

Webページにはリンク切れがしばしば起こる。これはDAppsにおいてもそのサービス提供部分のWebページに起こり得ることであり、DAppsが用いているブロックチェーンにはデータが永続的に保存されていることとの非対称性が問題となる。
また、この問題を解決するためにブロックチェーン上にWebリソースを配置するとなると、モノリシックなブロックチェーンに対してはアップロード速度が足りず、またメインチェーンに依存している場合は莫大な手数料がかかってしまう。

そこで本システムではCosmosを採用する。Ethereum等のレイヤ１と比較してメインチェーンに依存しないためGasLimitやGasPriceを柔軟に設定可能である点や、AppChain（アプリケーション固有チェーン）としてモジュラーなシステムを構築できることによる設計レベルでの自由度の高さに起因する。
またエコシステムとしても比較的巨大で活発なことも考慮に値する。

先行事例としては「Internet Computer」が存在するが、こちらはいささか大規模すぎることと、独自のブロックチェーンエコシステムを採用しており、移植性・発展性に欠けること、そして、このエコシステムにノードとして参加するためには審査と高いハードウェア要件が存在し、現実的にはパブリックブロックチェーンと言えるものではないため、これらの諸問題を解決するよりミニマムで汎用性の高いシステムを提案する。

### 1.2. システム概要

本システムは、複数のブロックチェーン（データチェーン）を束ねて管理する。
既存のストレージのようなデフラグが可能なシステムとは異なり、一度書き込んだデータを削除できないブロックチェーンとRAID技術は相性が悪いため、本PoCではデータの可用性に影響するRAIDのような技術の導入は保留とし、将来的な検討課題とする。

本システムの基本動作フローは以下の通りである。

  - クライアントはこのシステムにWEBリソースをアップロードしたり、通常のWEBサーバーのようにHTTPレスポンスを受け取ったり出来る。
  - WEBリソースを固定サイズの「データ断片」に分割する。
  - 各断片を、複数の「データチェーン」に並列で保存する。
  - どの断片がどのチェーンに保存されているかの所在情報（メタデータ）は、別途「メタデータチェーン」で一元管理する。
  - クライアントからのリクエストを受け、データの断片化・分散保存・復元・配信を行う「コントローラーチェーン」を中核コンポーネントとして配置する。
  - 各チェーンはIBCによって接続される。
  - このシステムには`http://raidchain.com`のような形でアクセスでき、`http://raidchain.com/<ProjectName>`のような感じでWebページを配信する。（例：`http://raidchain.com/example.com/index.html`）


このアーキテクチャにより、スケーラブルなオンチェーンWEBストレージを実現する。

### 1.3. 用語定義

  - **コントロールチェーン (controlchain)**
      - 各チェーンのオーケストレーションとオラクルとのゲートウェイを司るチェーン。現在オフチェーンに実装されているコントローラー自体もオンチェーンコンポーネントとしてシステムに組み込む。
  - **メタデータチェーン (metachain)**
      - どのデータ断片がどのデータチェーンにあるかというハッシュ情報（メタデータ）を記録・管理するブロックチェーン。
  - **データチェーン (datachain)**
      - 断片化されたWEBリソースの実データを保存するためのブロックチェーン。複数台稼働させる。
  - **リレイヤー (relayer)**
      - IBCプロトコルに基づき、各チェーン間の状態を同期させるために必要なコンポーネント。
  - **IBC (Inter-Blockchain Communication)**
      - ブロックチェーン間で通信する技術。イーサリアムなどではブリッジを介して行うが、CosmosではRelayerを用いて行う。
  - **Cosmos SDK**
      - Cosmosは単一のブロックチェーンではなくCosmos SDKを使って作られたAppChainの総称。Cosmosというエコシステムに乗っかったブロックチェーンを設計開発するための開発キット。
  - **DENOM (denomination)**
      - 貨幣単位のこと。Cosmosで使われるATOMやBitcoinのBTCは「トークン」であり、その最小単位がDENOM。
      - Cosmosでは一般的に「**uatom**」というDENOMが使われる（uはマイクロ。1ATOM = 1,000,000uatom）。
  - **ウォレット**
      - 複数のアカウントを束ねる最大単位。ニーモニックから生成されるマスターシード（シード値）を元に生成・復元される。
      - マスターシードは最終的に秘密鍵になるが、これを導くプロトコルが**BIP-44**である。ウォレットはマスターシードから導出された秘密鍵（親の秘密鍵）を持つ。
  - **ニーモニック**
      - ウォレット全体を表すマスターキー（シード値）を、人間が読み書きしやすいように12単語または24単語の英単語の羅列で表現したもの。
      - 生成プロトコルは**BIP-39**で規定される。アカウントやアドレスは、このニーモニック（マスターシード）とHD Pathによって**決定論的**に生成されるため、ニーモニックさえあれば取引記録や残高の復元が可能。
  - **アカウント**
      - ブロックチェーンの種類や使用用途ごとに作られる単位。口座に近い概念。
      - アドレス作成時にボトムアップ的に作成される。
      - 複数のアドレスを内包する論理的な区切りであり、実体はない。
      - 一つのトランザクションに対して、同一アカウント内であれば複数のアドレスが署名可能であるため、特定のアドレスの残高が不足していても、ウォレットアプリが自動で同アカウント内の複数アドレスを使用して支払うような処理が可能（CosmosやEthereumの場合、お釣り用アドレスは使用せずアカウントから残高を引き算する）。
  - **アドレス**
      - ブロックチェーン上で何かを行うときの最小単位。口座番号や名義のようなもの。
      - 現実の口座番号と異なり無制限に作成可能であり、取引ごとにアドレスを変更することも可能。
      - **HD Path**という識別子から作成される。
      - 残高を持つ実体はこのアドレスであるが、ウォレットアプリ上ではアカウント単位で残高を持つように見かけ上は見える。
      - それぞれのアドレスがHD Pathから導出された秘密鍵（子の秘密鍵）を持つ。
  - **HD Path (Hierarchical Deterministic Path: 階層的決定性パス)**
      - アドレスを生成し、そのアドレスに対応する秘密鍵を導出するために使われるパス。アドレスやアカウントを区別する識別子のような役割を持つ。
      - HD Pathを元に作られるのは「アドレス」だが、そのパスの中に「アドレスがどのアカウントに属するのか」という情報が含まれているため、アカウントは論理的な存在としてボトムアップ的に生成される。
      - スラッシュ（/）で区切られた以下の5つの階層レベルで構成される。
        `m / purpose' / coin_type' / account' / change / address_index`
        1.  **m**: マスターシードを起点とすることを表すシンボル。
        2.  **purpose'**: 目的。値は常に**44**。このパスがBIP-44規格に従っていることを示す。
        3.  **coin\_type'**: ブロックチェーンの種類ごとに規定される値。Bitcoinは「0」、Cosmosは「**118**」。
        4.  **account'**: アカウントを区別する数字。0から始まる。
        5.  **change**: Bitcoinなど、UTXOを用いた「お釣り」が発生する場合に必要な値。CosmosやEthereumはアカウントベースのため通常は使用しない（0など）。
        6.  **address\_index**: アドレスを識別する値。
      - **Hardened Derivation（ハード化導出）**:
          - パス内の「'（アポストロフィ）」はHardened Derivationを行うことを明示的に示す印である。
          - これがある場合、「必ず親の秘密鍵がなければ子の秘密鍵を導出できない」ことを示す。
          - 逆にこれがなければ「親の公開鍵」だけで子の公開鍵などを導出できる（拡張公開鍵などの機能）。
    - **プロジェクト**
        - このシステムにアップロードしホスティングするものを「プロジェクト」と呼ぶ。
        - ホスティングするプロジェクト名を`ProjectName`とし、ホスティングするコンテンツを`Asset`と呼ぶ。
        - `Asset`には`File`と`Directory`を指定できる。`index.html`というファイルだけをアップロードすることも出来るし、ディレクトリ全体をアップロードすることも出来る。
        - `EntryPoint`には、このプロジェクトサイトにアクセスしたときにデフォルトで開くファイルを指定できる。デフォルトはindex.html
        - ディレクトリをアップロードした場合、pwdは自動的にルートディレクトリになり、ルートディレクトリの名前はURLに表示されない。
            - 例
                ```
                [ProjectName]
                example.com

                [Asset]
                project-root/
                ├── index.html
                └── assets/
                    └── image.png

                [EntryPoint]
                index.html

                →URL："http://raidchain.com/example.com/index.html
                ```
        - 構造
            ```typescript
            /**
            * ユーザーが定義するプロジェクト構造
            */
            type Project = {
                /**
                * URLの一部となるプロジェクト識別子 (例: "example.com")
                */
                ProjectName: string;

                /**
                * アップロード対象の実体
                * ファイル単体、またはディレクトリを指定可能
                */
                Asset: File | Directory;

                /**
                * ルートアクセス時に表示するファイル (省略可)
                * @default "index.html"
                */
                EntryPoint?: string; 
            };

            // 内部的に扱うための型定義イメージ
            type Directory = {
                path: string; // ローカルのディレクトリパス
                // 再帰的な構造や、内包するファイルリストなど
            };

            type File = {
                path: string;
                content: Uint8Array; // バイナリデータ
            };
            ```
## 2\. 基本要件

### 2.1. 利害関係者（ステークホルダー）

  - **デプロイヤー（ホスト）**
      - このシステムにデータをアップロードし、WEBページをホスティングする利用者。
  - **ビューワー（クライアント）**
      - このシステムでホスティングされたページを閲覧する利用者。
  - **デベロッパー**
      - このシステムを開発・管理する開発者。

### 2.2. システムのスコープ

  - **提供する機能（Scope In）**
      - WEBリソース（ファイル）のアップロード機能（URLに紐づけてまとまりを作成）。
      - URLを指定したWEBリソースのダウンロード機能（ブラウザ表示はクライアント側で実施）。
  - **提供しない機能（Scope Out）**
      - **ファイルの更新・削除:** ブロックチェーンの特性上、物理削除は行わない。論理削除での対応とする。古いバージョンの閲覧機能は本PoCでは対応しない。
      - **認証・アクセス制御:** 静的なサイトやクライアント側のみでの処理に限定する。サーバーサイドロジックが必要な認証等はオフチェーン実装等の扱いとし、本システムのコア機能としては提供しない。
      - **課金モデル:** マネタイズの仕組みはPoCを複雑化させるため考慮しない。ただし、システム内部的なガス代の設計（コスト配分）については考慮する。

## 3\. 機能要件

### 3.1. 機能一覧

  - **必須機能**
      - データのアップロード
      - データのダウンロード
      - データのアップデート（論理更新）
      - データの削除（論理削除）
  - **低優先度（PoC範囲外となる可能性あり）**
      - アップロードされたファイルの一覧表示機能
      - ファイルの検索機能
      - 古いバージョンの適用や閲覧

### 3.2. 業務フロー（ユースケース）

#### 3.2.1. アップロード処理

URLの重複を「コントロールチェーンによる事前チェック」と「`metachain`による最終保証」のハイブリッド方式で防止する。

| ステップ | 担当 | アクション |
| :--- | :--- | :--- |
| **1. 指示** | **クライアント** | アップロードしたいWEBリソース（ディレクトリ）と公開したい**ルートURL**を**コントロールチェーン**に渡す。 |
| **2. URL重複確認** | **コントロールチェーン** → **Metachain** | **【事前チェック】** まず、指定されたルートURLが`Metachain`に既に存在しないか**クエリ**で問い合わせる。**存在した場合はエラーを返し、処理を中断する。** |
| **3. 分割** | **コントロールチェーン** | 受け取ったリソース内の各ファイルを固定サイズの「データ断片」に分割し、任意で「パリティ断片」を生成する。 |
| **4. 分散保存** | **コントロールチェーン** → **Datachain** | 各断片を、それぞれ別の**Datachain**に並列で送信し、保存先を示す`Index`を受け取る。 |
| **5. マニフェスト作成** | **コントロールチェーン** | 全てのファイルの「相対パス」と、それに対応する「`Index`のリスト」をまとめた**マニフェスト（ファイル構成情報）を作成する。 |
| 6. マニフェスト登録 | コントロールチェーン → Metachain | 作成したマニフェストをルートURLに紐付けて`Metachain`に登録するトランザクションを送信する。<br>【最終保証】** 万が一、重複したURLでトランザクションが送信された場合、`Metachain`自体のロジックがこれを拒否し、データの整合性を保証する。 |
| **7. 完了** | **コントロールチェーン** → **クライアント** | `Metachain`への登録完了後、クライアントに完了通知を送る。 |

#### 3.2.2. ダウンロード処理

| ステップ | 担当 | アクション |
| :--- | :--- | :--- |
| **1. 要求** | **クライアント** | 閲覧したいURLを**コントロールチェーン**に渡す。 |
| **2. 住所確認** | **コントロールチェーン** → **Metachain** | **Metachain**にURLに対応するメタデータ（住所録）を問い合わせる。 |
| **3. 住所取得** | **Metachain** → **コントロールチェーン** | **Metachain**は「断片データのありかリスト」をコントロールチェーンに返却する。 |
| **4. データ収集** | **コントロールチェーン** → **Datachain** | リストに基づき、各**Datachain**にデータ断片を並列で問い合わせる。 |
| **5. 結合・復元** | **コントロールチェーン** | 全てのデータ断片を結合して元のファイルを復元する。（一部欠損時はパリティ断片で復元） |
| **6. 表示** | **コントロールチェーン** → **クライアント** | 復元したファイルをクライアントに渡し、表示させる。 |

### 3.3. データ要件

#### `datachain`

  - **方式:** `index`と`data`フィールドで構成された**Key-Value型のデータ構造**を採用。
  - **構造:**
    ```json
    {
        "stored_chunk":{
            "index":"string", // Base64 Encoded Hash
            "data" :"string", // Chunk of FileData (Base64 Encoded or Binary)
        },
    }
    ```
  - **概要:**
      - 断片化されたWEBリソースデータを保存する。`index`は`<URLなどを元にしたハッシュ>-<連番>`のような形式にし、保存の順序を固定化する。
      - `data`にはWEBリソースデータのチャンクを保存する。保存形式は以下のいずれかを採用。
        1.  **ファイルの内容そのもの**を分割し、Base64エンコードして保存
        2.  **ファイルをバイナリとして分割**し、Binaryとして保存

#### `metachain`

  - **方式:** **マニフェスト方式**を採用。
  - **構造:**
    ```json
    {
        "stored_manifest":{
            "index": "string", // Unique Key (Base64 URL safe)
            "manifest": "string", 
            /* manifest is JSON string
                { "[filePath: string]": "string[] (stored_chunk IndexHash List)" }
            */
            "domein": "string", // site_url (ex test-site.com)
            "creator": "string", // cosmos signer's address
        },
    }
    ```
  - **概要:**
      - 特定のWEBサイトやリソース群を、一つのまとまりとして管理する。
      - `index`: `metachain`内での**ユニークキー**。Base64 URL safeエンコードを使用。
      - `domein`: サイトのルートとなる一意なパス（例: `test-site.com`）。
      - `manifest`: サイト内のファイル構成を定義するオブジェクト。
          - キー：相対パス（例: `/index.html`）。
          - バリュー：各ファイルの実体を構成するデータ断片の`Index`（`datachain`上のアドレス）リスト。

#### `controlchain`

  - **方式:** Cosmos SDK AppChain
  - **概要:**
      - ファイルの分割/集約、Datachain・Metachainへのデータ保存、WEBページホスティングなど、システムのオーケストレーション全てを司る中核チェーン。

### 3.4. 管理機能要件

  - **監視機能:** 各チェーン（metachain, datachain）の死活監視やリソース（ディスク使用量、トランザクション詰まり等）を監視する機能。
  - **構成管理:** 新しいデータチェーンをシステムに追加・削除する手順の確立。

### 3.5. 異常系（エラーハンドリング）要件

  - **アップロード異常:** アップロード中に一部のデータチェーンが応答しない場合のリトライ処理、タイムアウト処理、エラー通知の仕様。
  - **書き込み失敗:** メタデータチェーンへの書き込みが失敗した場合のロールバック処理の仕様。
  - **システムダウン:** コントロールチェーン自体がダウンした場合の縮退運転や復旧手順。

## 4\. 非機能要件

### 4.1. 性能・拡張性

  - **目標性能（PoC）:**
      - MBレベルのデータのアップロードが可能であること。
      - チェーンを増やすことによるアップロード速度の向上が確認できること。
      - WEBリソースをHTTP通信によって取得する「WEBサーバのような運用」が実現できること。

### 4.2. 運用・保守性

  - **環境構築:** `datachain`, `metachain`, `relayer`, `controlchain` の各コンポーネントにおけるコンテナ構築手順の確立。
  - **自動化:** 各チェーンの起動時に、設定ファイル（`genesis.json`, `config.toml`, `app.toml`）を自動生成・構成する仕組み。
  - **冪等性:** 何度実行しても同じ状態になることを考慮した初期化スクリプトの設計。
  - **ログ設計:** 各コンポーネントが出力するログの内容はデフォルト設定に準拠する。
  - **監視設計:** 各コンポーネントの基本メトリクス監視を行う。
  - **バックアップ・リストア:** チェーンの状態はk8sのPVC（Persistent Volume Claim）に保存する。PoCのため、障害発生時の詳細な復旧フローは考慮しない。

### 4.3. UI/UX要件

  - 詳細なUI/UX要件については、別途定義される`WebUI要件`を参照のこと。

## 5\. 制約条件

### 5.1. 技術的制約

  - **ブロックチェーン基盤:** Cosmos SDKを利用して独自のチェーンを構築する。
  - **チェーン間通信:** IBC (Inter-Blockchain Communication) プロトコルを利用する。
  - **実行環境:** 各コンポーネントはContainer/Podとして構築し、Helm ChartとKubernetes(k8s)によるオーケストレーションを想定する。
  - **開発言語:** Go（Cosmos SDK標準）。
  - **アーキテクチャ:**
      - コントローラーは`controlchain`による完全オンチェーンコンポーネントとして実装する。
      - システムのコントローラーとは別に、システムのモニタリングや効率的に実験を行うためのユーティリティWebUIをオフチェーンに構築する。