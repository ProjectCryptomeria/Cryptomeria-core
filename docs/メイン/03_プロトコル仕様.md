---
DocType: SPEC
SourceOfTruth: CSUプロトコル.md
Status: draft
LastReviewed: 2026-01-26
Owners: TBD
---

# Protocol Spec（Cryptomeria 独自機構）— CSU準拠版

## 1. 目的
本書は “Cryptomeria-Core 独自の仕組み” を **CSUプロトコル.md** に整合する形で仕様として固定します。

本書が規定する対象：
- **CSU session（アップロード単位）**
- **HTTP/TUS による ZIP アップロード（チャンク/再開）**
- **RootProof（解凍後ZIP内容コミット）**
- **Merkle proof / root proof（verify_fragment）**
- **オンチェーン配送（MsgDistributeBatch）と IBC packet（fragment/manifest）**
- **Authz + Feegrant（session寿命同期）**
- **Session Close（完了/失敗時にTxの一環として閉鎖）**
- Endpoint registry
- ACK/timeout/失敗時の意味（※Closeの扱いはCSUに従う）

---

## 2. 用語
- **Owner**：データ所有者（セッション作成者、例：Alice）
- **Executor**：アップロード処理を実行する主体（固定で `local-admin` を推奨）
- **Session**：アップロード単位（CSU）。`session_id` で識別
- **TUS**：レジューム可能HTTPアップロード。ZIPをチャンクで送る
- **session_upload_token**：TUSアップロードに必要な capability（InitSessionで払い出し）
- **Fragment**：解凍後ファイルを `fragment_size` で分割した断片
- **Manifest**：参照解決情報（project/version/files/root_proof 等）
- **RootProof**：解凍後ZIP内容（正規化ファイル集合）から算出する決定論コミットメント（Merkle Root）
- **MerkleProof**：Fragment が RootProof に含まれることを示す証明（推奨：二段 proof）
- **Session Close**：Session を閉じる（以後の後続操作を不可にし、Authz/Feegrant も寿命一致で終了させる）

---

## 3. 参加者（CSU準拠）
- Owner（Alice）
- Executor（local-admin / GWC genesis account 推奨）
- GWC chain（CSU session を管理）
- FDSC-* chains（fragment を保存）
- MDSC chain（manifest を保存）
- Executor Node g（local-admin 鍵でTx投下・ZIP資材取り扱い・断片化/Proof生成を行うノード）
- TUS server（ZIPアップロードのHTTPエンドポイント。GWC/Executor運用でも可）

---

## 4. CSU Session モデルと状態機械（Closeを明確化）

### 4.1 Session フィールド（推奨）
- `session_id: string`
- `owner: bech32`
- `executor: bech32`（固定：local-admin 推奨）
- `root_proof: string`（hex）
- `fragment_size: uint64`
- `deadline: timestamp`（session寿命の上限）
- `limits: { max_bytes, max_fragments }`（任意）
- `state: enum`
- `close_reason: string`（任意）

### 4.2 状態（Normative）
| State | 説明 |
|---|---|
| INIT | session 作成直後 |
| ROOT_COMMITTED | RootProof コミット済み |
| UPLOAD_IN_PROGRESS | TUSアップロード進行中（追跡する場合） |
| UPLOADED | ZIPアップロード完了（サーバが確認） |
| DISTRIBUTING | 断片配布中 |
| FINALIZING | manifest確定処理中（任意） |
| CLOSED_SUCCESS | 正常完了として閉鎖（最終状態） |
| CLOSED_FAILED | 失敗として閉鎖（最終状態） |

### 4.3 Close の規則（必須）
- `CLOSED_*` は最終状態であり、以降は以下を **一切許可しない**：
  - DistributeBatch
  - FinalizeAndClose（再実行含む）
  - AbortAndClose（再実行含む）
  - RootProof再コミット
  - HTTPアップロードの継続（TUSサーバ側も拒否推奨）

- Close と同時に（推奨）：
  - session_id 固定の authz grant を revoke
  - feegrant allowance を revoke（Alice→local-admin）

---

## 5. プロトコル全体フロー（CSU準拠）

### Phase 0：事前準備（One-time / per session）
- Faucet：`local-admin -> owner`（必要なら）
- Feegrant：`owner -> local-admin`（session寿命分）
- Authz：`owner -> local-admin`（**session_id固定**、expiration を session.deadline と同一推奨）

### Phase 1：Session開始（Tx）
1) `MsgInitSession(owner, fragment_size, limits?, deadline?)`
- 出力：`session_id`, `session_upload_token`, `deadline`
- state：INIT

### Phase 2：RootProof作成 & コミット（Tx）
2) Owner は ZIP を解凍し RootProof を計算（後述 RootProof v1）
3) `MsgCommitRootProof(owner, session_id, root_proof)`
- state：ROOT_COMMITTED

### Phase 3：ZIPアップロード（HTTP/TUS）
4) Owner は **HTTP/TUS** で ZIP を **チャンク/再開**によりアップロードする
- `session_upload_token` を必須
- 完了条件：`Upload-Offset == Upload-Length`
- state：UPLOAD_IN_PROGRESS（追跡するなら）→ UPLOADED

> 規範：**クライアントは分割トランザクションで断片を送らない。**  
> 断片配布Txは Executor（local-admin）が Authz+Feegrant により代理実行する。

### Phase 4：断片化 & proof生成（Executor Node g / オフチェーン）
5) g は ZIP を取得・安全に解凍し、`fragment_size` で断片化して `(path,index,fragment_bytes)` を生成
6) verify_fragment に適合する MerkleProof（推奨：二段）を生成

### Phase 5：配布（複数Tx; local-admin 実行）
7) `MsgDistributeBatch(executor=local-admin, session_id, items[])`（複数回可）
- on-chain ゲート：verify_fragment（必須）
- state：DISTRIBUTING

### Phase 6：確定 & Close（Txの一環として session を閉じる）
8) `MsgFinalizeAndCloseSession(executor=local-admin, session_id, manifest)`
- IBC：manifest を MDSC に送信
- **Close（必須）**：state を `CLOSED_SUCCESS` に遷移し、必要なら revoke（authz/feegrant）
- state：CLOSED_SUCCESS

### Phase 7：失敗 & Close（Txの一環として session を閉じる）
9) `MsgAbortAndCloseSession(executor=local-admin, session_id, reason)`
- **Close（必須）**：state を `CLOSED_FAILED` に遷移し、必要なら revoke（authz/feegrant）
- state：CLOSED_FAILED

---

## 6. RootProof v1（Merkle）仕様（CSU準拠：Normative）

### 6.1 RootProof 計算対象（重要）
- **ZIPを解凍した後のファイル集合**が対象
- ZIPバイト列差（圧縮方式/メタデータ）は RootProof に影響しない
- 同一の展開内容なら RootProof は同一

### 6.2 ZIP展開の安全要件（Owner/Executor 共通）
- `\` → `/` 正規化
- `path.Clean` 相当の正規化
- 絶対パス禁止
- `../` を含むパス禁止（Zip Slip対策）
- 先頭 `/` と `./` 除去
- 展開総量上限（例：100MB）を設定（limits に含めてもよい）

### 6.3 RootProof v1 詳細
- ハッシュ：SHA-256
- Merkle：binary merkle、奇数は末尾複製
- 決定論順序：ファイルは `path` 昇順、断片は `index` 昇順

**Fragment leaf**
- `leaf_frag = SHA256("FRAG:{path}:{index}:{hex(SHA256(fragment_bytes))}")`

**File root**
- `file_root = MerkleRoot(leaf_frag_hex[])`

**File leaf**
- `leaf_file = SHA256("FILE:{path}:{file_size}:{file_root}")`

**RootProof**
- `root_proof = MerkleRoot(leaf_file_hex[])`

**MerkleRoot**
- 入力が奇数なら末尾複製
- 親：`hex(SHA256(left_hex + right_hex))`（hex文字列連結をsha）

---

## 7. Proof 検証（verify_fragment：Normative）

### 7.1 二段証明（推奨）
- FragmentProof：`leaf_frag` が `file_root` に含まれる証明
- FileProof：`leaf_file` が `root_proof` に含まれる証明

### 7.2 verify_fragment 入力
- `root_proof`（session保持）
- `path, index, fragment_bytes`
- `fragment_proof`
- `file_size, file_proof`

### 7.3 verify_fragment 手順（Normative）
1. `leaf_frag = H("FRAG:{path}:{index}:{hex(H(fragment_bytes))}")`
2. `file_root = MerkleVerifyRoot(leaf_frag, fragment_proof)`
3. `leaf_file = H("FILE:{path}:{file_size}:{file_root}")`
4. `computed_root = MerkleVerifyRoot(leaf_file, file_proof)`
5. `computed_root == root_proof` を要求（不一致なら失敗）

---

## 8. 権限設計（Authz + Feegrant）— session寿命同期（CSU準拠）

### 8.1 目標
- local-admin が **当該 session に限って**配布/確定/中止を実行できる
- session が閉じられたら **Authz も同時に終了**する（寿命一致）

### 8.2 Authz（session_id固定）
Owner は local-admin に対して、少なくとも以下の操作を `session_id` 固定で許可する：
- `MsgDistributeBatch(session_id=...)`
- `MsgFinalizeAndCloseSession(session_id=...)`
- `MsgAbortAndCloseSession(session_id=...)`

必須条件（いずれか）：
- A) Authorization が `session_id` を内包し `msg.session_id` 一致を強制（推奨）
- B) Msg側ハンドラで `session.owner/executor/authz grant` を検証し、session逸脱を不可能にする（最低条件）

### 8.3 Authz寿命＝session寿命（必須）
1) **論理的無効化（必須）**  
   - session が `CLOSED_*` なら後続Msgを必ず拒否する（grantが残っても実効的に無効）

2) **物理的撤去（推奨）**  
   - `FinalizeAndClose` / `AbortAndClose` のTx処理内で該当 grant を revoke

### 8.4 Feegrant（Alice肩代わり）
- 配布/確定/中止Txの fee は Feegrant により Owner が負担
- Feegrant寿命も session に同期（推奨）：
  - Close系Tx処理内で allowance revoke
  - もしくは expiration を session.deadline に一致（最低限）

---

## 9. メッセージ仕様（CSU準拠：Normative）

### 9.1 MsgInitSession
- 入力：
  - `owner`
  - `fragment_size`
  - `limits?`
  - `deadline?`（チェーン側決定し保存でも可）
  - `executor`（固定：local-admin 推奨）
- 出力：
  - `session_id`
  - `session_upload_token`
  - `deadline`
- 遷移：INIT

### 9.2 MsgCommitRootProof
- 入力：`session_id`, `root_proof`
- 検証：
  - signer == session.owner
  - session.state が INIT/ROOT_COMMITTED（再コミット可否は設計次第。推奨：一回のみ）
  - hex妥当性
- 遷移：ROOT_COMMITTED

### 9.3 MsgDistributeBatch
- 入力：`session_id`, `items[]`
  - `path`
  - `index`
  - `fragment_bytes`
  - `fragment_proof`
  - `file_size`
  - `file_proof`
  - `target_fdsc_channel?`
- 検証（必須）：
  - signer == local-admin
  - session.state が `CLOSED_*` でない
  - authz が session_id 固定で有効
  - verify_fragment(...) が真
  - (path,index) の重複拒否
  - limits 超過拒否
- 遷移：DISTRIBUTING（進行）

### 9.4 MsgFinalizeAndCloseSession
- 入力：`session_id`, `manifest`
- 検証（必須）：
  - signer == local-admin
  - session が `CLOSED_*` でない
  - authz が session_id 固定で有効
  - manifest.root_proof == session.root_proof
  - 配布完了条件（設計に応じて）
- 処理：
  - MDSC へ IBC で manifest 送信
  - **state = CLOSED_SUCCESS（必須）**
  - close_reason = "SUCCESS"（任意）
  - authz revoke（推奨）
  - feegrant revoke（推奨）

> NOTE：Close の成立は **MDSC ACK の成功を待たず**、本Msg処理の一環として行う（CSU準拠）。

### 9.5 MsgAbortAndCloseSession
- 入力：`session_id`, `reason`
- 検証（必須）：
  - signer == local-admin
  - session が `CLOSED_*` でない
  - authz が session_id 固定で有効（または signer=local-admin を特例許可する設計も可）
- 処理：
  - **state = CLOSED_FAILED（必須）**
  - close_reason = reason（推奨）
  - authz revoke（推奨）
  - feegrant revoke（推奨）
  - （任意）TUSストレージ上の資材をGC対象へ

---

## 10. HTTP/TUS アップロード仕様（CSU準拠）

### 10.1 認可（必須）
TUSアップロードには `session_upload_token` を必須とする。
- `InitSession` の応答で発行される（または同等の手段）

### 10.2 典型フロー（例）
- `POST /files`（作成）
- `PATCH /files/<id>`（Upload-Offsetを進めてチャンク送信）
- `HEAD /files/<id>`（進捗確認）
- 完了条件：`Upload-Offset == Upload-Length`

### 10.3 失敗の定義（例）
- 期限（session.deadline）までに完了しない
- TUSストレージが破損/消失
- Owner が Abort を希望
- サーバが整合しないメタデータを検出

> 失敗時の session close は **AbortAndCloseSession（Tx）で行う**。

---

## 11. IBC Packet 仕様（概要）

### 11.1 FragmentPacket（GWC → FDSC）
主目的：fragment を datastore に保存する。

含むべき情報（規範）：
- session_id
- path
- index
- fragment_bytes
- fragment_proof（rootへの到達を証明）
- file_proof / file_size（必要なら）

### 11.2 ManifestPacket（GWC → MDSC）
主目的：manifest を metastore に保存する。

含むべき情報（規範）：
- project_name
- version
- files（path→metadata）
- root_proof
- fragment_size
- owner
- session_id

### 11.3 ACK と Timeout（位置づけ）
- FDSC ACK：保存の可否（success / conflict / invalid）
- MDSC ACK：manifest 保存の可否（success / invalid / rejected）
- timeout：relayer/接続不調等で ACK が返らなかった場合

> NOTE（CSU準拠）：Session Close は Close系Msgで完了する。  
> ACK/timeout は監視・監査・運用上の重要情報として **別途記録/通知**することを推奨する（Close状態自体は巻き戻さない）。

---

## 12. 分散配送（FDSC 選択規則）
- `target_fdsc_channel` 指定がある場合：その FDSC に送る
- 指定がない場合：登録済み datastore channel の集合から選ぶ（例：round-robin）
- 規範：FDSC 増設後、**接続 + endpoint 登録**が完了して初めて分散先に含める

---

## 13. Manifest 更新規則（MDSC）
- 同一 project_name の下で version をキーに保持
- `files[path]` は上書きまたはマージ（規範として決める：immutable version 推奨）
- 保存は冪等であるべき（同一 manifest の再送は成功）

---

## 14. Endpoint Registry（GWC）

### 14.1 StorageInfo
- channel_id：IBC channel
- chain_id：識別子（例：mdsc, fdsc-0）
- api_endpoint：`http://...:1317` 形式を推奨
- connection_type：`mdsc` または `fdsc`

### 14.2 TUS Endpoint（推奨）
- tus_endpoint：`http(s)://.../files`（例）
- session_upload_token の検証方式（JWT等）は実装依存だが、**token必須**は規範

### 14.3 登録
- Local admin が `MsgRegisterStorage` を発行して登録/更新する
- Deploy レイヤーの接続スクリプトが登録を自動化する

---

## 15. セキュリティ/整合性の保証範囲
- 改ざん検出：proof により可能（保存先を信用しない）
- 可用性：構成依存（FDSC増設/relayer冗長化等で改善）
- 権限濫用：session_id 固定の Authz + Close による寿命同期で抑止（Feegrant も同様）

---

## 16. 変更ルール
- 本書（SPEC）を変更する場合は、互換性の影響を必ず明記する
- Use-case/Deploy/Client も同時更新し、整合を保つ
- 仕様の正は **CSUプロトコル.md** とし、本書はそれに追随する
